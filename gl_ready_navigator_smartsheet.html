<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HPE GreenLake Ready Process Navigator</title>
    <style>
        :root {
            /* Primary Colors */
            --hpe-green: #01A982;
            --hpe-dark-green: #008567;
            --hpe-gray: #425563;
            
            /* Neutral Colors */
            --hpe-light-gray: #F5F5F5;
            --hpe-border: #E0E0E0;
            --text-primary: #333;
            --text-secondary: #666;
            
            /* Background Colors */
            --body-background: #F9F9F9;
            
            /* Connection colors */
            --connection-color: #01A982;
            --connection-hover: #008567;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--body-background);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, #01A982 0%, #008567 100%);
            color: white;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        
        .header h1 {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        /* Main Container */
        .container {
            padding: 2rem;
            padding-bottom: 80px; /* Space for bottom scrollbar */
        }
        
        /* Sticky top scrollbar */
        .scroll-wrapper-top {
            position: sticky;
            top: 0;
            z-index: 100;
            background: #f5f7fa;
            padding: 10px 0;
            overflow-x: auto;
            overflow-y: hidden;
            height: 24px;
            border-bottom: 1px solid #ddd;
        }
        
        .scroll-wrapper-top-inner {
            height: 1px;
        }
        
        /* Sticky bottom scrollbar */
        .scroll-wrapper-bottom {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: #f5f7fa;
            padding: 10px 2rem;
            overflow-x: auto;
            overflow-y: hidden;
            height: 24px;
            border-top: 1px solid #ddd;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
        }
        
        .scroll-wrapper-bottom-inner {
            height: 1px;
        }
        
        /* Controls */
        .controls {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .view-toggle {
            display: flex;
            background: var(--hpe-light-gray);
            border-radius: 8px;
            padding: 4px;
        }
        
        .view-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .view-btn:hover {
            color: var(--hpe-green);
        }
        
        .view-btn.active {
            background: white;
            color: var(--hpe-green);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .view-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border: 2px solid var(--hpe-border);
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .controls label:hover {
            border-color: var(--hpe-green);
            background: #E8F5F1;
        }
        
        .controls input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--hpe-green);
        }
        
        .controls span {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .show-all-btn {
            display: none;
            padding: 0.5rem 1.25rem;
            background: var(--hpe-green);
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
        }
        
        .show-all-btn:hover {
            background: #008567;
            transform: scale(1.02);
        }
        
        body.panel-open .show-all-btn {
            display: block;
        }
        
        /* Global Search */
        .global-search-wrapper {
            margin-bottom: 1rem;
        }
        
        .global-search-box {
            display: flex;
            align-items: center;
            background: white;
            border: 2px solid var(--hpe-border);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            transition: all 0.2s;
        }
        
        .global-search-box:focus-within {
            border-color: var(--hpe-green);
            box-shadow: 0 0 0 3px rgba(1, 169, 130, 0.1);
        }
        
        .global-search-box .search-icon {
            color: var(--text-secondary);
            margin-right: 0.75rem;
            flex-shrink: 0;
        }
        
        .global-search-input {
            flex: 1;
            border: none;
            outline: none;
            font-size: 1rem;
            font-family: inherit;
            background: transparent;
        }
        
        .global-search-input::placeholder {
            color: #999;
        }
        
        .clear-search-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: var(--hpe-light-gray);
            color: var(--text-secondary);
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 0.5rem;
            transition: all 0.2s;
        }
        
        .clear-search-btn:hover {
            background: #ffebee;
            color: #c62828;
        }
        
        .search-results-count {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding-left: 0.5rem;
        }
        
        .search-results-count.has-results {
            color: var(--hpe-green);
        }
        
        .search-highlight {
            background: #FFF59D;
            padding: 0 2px;
            border-radius: 2px;
        }
        
        /* Collapsible Filters */
        .filters-container {
            margin-bottom: 1rem;
        }
        
        .filters-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 0.75rem 1rem;
            background: white;
            border: 2px solid var(--hpe-border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--hpe-gray);
            transition: all 0.2s;
        }
        
        .filters-toggle:hover {
            border-color: var(--hpe-green);
            color: var(--hpe-green);
        }
        
        .filters-toggle-text {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .filters-badge {
            background: var(--hpe-green);
            color: white;
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            margin-left: 0.5rem;
        }
        
        .filters-chevron {
            transition: transform 0.3s;
        }
        
        .filters-container.collapsed .filters-chevron {
            transform: rotate(-90deg);
        }
        
        .filters-container.collapsed .filters {
            display: none;
        }
        
        .filters-container .filters {
            margin-top: 0.5rem;
            border-radius: 0 0 8px 8px;
        }
        
        /* Filters */
        .filters {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 2rem;
        }
        
        .filters h3 {
            color: var(--hpe-gray);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .filters h3::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--hpe-green);
            border-radius: 2px;
        }
        
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }
        
        .filter-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .filter-option:hover {
            border-color: var(--hpe-green);
            background: #E8F5F1;
        }
        
        .filter-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--hpe-green);
        }
        
        .filter-option label {
            cursor: pointer;
            font-size: 0.9rem;
            flex: 1;
        }
        
        .filter-count {
            font-size: 0.85rem;
            color: var(--text-secondary);
            background: var(--hpe-light-gray);
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 600;
        }
        
        .filter-section {
            margin-bottom: 1.5rem;
        }
        
        .filter-section:last-of-type {
            margin-bottom: 0;
        }
        
        .category-filter-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .category-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            color: white;
        }
        
        .category-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .category-chip.inactive {
            opacity: 0.4;
            filter: grayscale(50%);
        }
        
        .category-chip.inactive:hover {
            opacity: 0.7;
        }
        
        .category-chip .chip-count {
            background: rgba(255,255,255,0.3);
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }
        
        .clear-filters {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background: white;
            border: 2px solid var(--hpe-green);
            color: var(--hpe-green);
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .clear-filters:hover {
            background: var(--hpe-green);
            color: white;
        }
        
        .filter-actions {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .hide-empty-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .hide-empty-toggle input {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--hpe-green);
        }
        
        .hide-empty-toggle span {
            font-weight: 500;
        }
        
        /* Hidden track when filtered */
        .track.hidden-track {
            display: none !important;
        }
        
        /* Hidden station when filtered and condensed */
        .station.hidden-station {
            display: none !important;
        }
        
        /* Subway Map Container */
        .subway-map-container {
            position: relative;
            overflow-x: auto;
            padding-bottom: 3rem;
        }
        
        .subway-map {
            background: white;
            padding: 2rem 1.5rem;
            padding-bottom: 5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: inline-flex;
            gap: 1rem;
            position: relative;
            min-width: 100%;
        }
        
        /* SVG Connection Layer - behind tracks by default */
        .connections-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
            overflow: visible;
        }
        
        /* Bring connections to front when panel is open */
        body.panel-open .connections-layer {
            z-index: 200;
        }
        
        .connection-line {
            fill: none;
            stroke: var(--connection-color);
            stroke-width: 4;
            opacity: 0.35;
            transition: all 0.3s;
        }
        
        .connection-line.highlighted {
            stroke: var(--connection-hover);
            stroke-width: 6;
            opacity: 1;
        }
        
        .connection-line.greyed {
            opacity: 0.05;
            stroke: #e0e0e0;
        }
        
        .connection-arrow {
            fill: var(--connection-color);
            opacity: 0.35;
            transition: all 0.3s;
        }
        
        .connection-arrow.highlighted {
            fill: var(--connection-hover);
            opacity: 1;
        }
        
        .connection-arrow.greyed {
            opacity: 0.05;
            fill: #e0e0e0;
        }
        
        /* Vertical Track */
        .track {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 160px;
            position: relative;
        }
        
        .track-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: white;
            padding: 1rem 0;
            margin-bottom: 2rem;
        }
        
        .track-label {
            background: var(--hpe-gray);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 16px;
            font-weight: 600;
            font-size: 0.75rem;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            text-align: center;
            min-width: 140px;
            line-height: 1.2;
            max-width: 160px;
        }
        
        .track-line {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            padding-bottom: 100px;
        }
        
        .track-rail {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            background: var(--hpe-border);
            z-index: 1;
            border-radius: 10px;
        }
        
        /* Station/Node */
        .station {
            position: relative;
            z-index: 5;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .station:hover:not(.greyed-out) {
            transform: scale(1.05);
            z-index: 6;
        }
        
        .station.greyed-out {
            opacity: 0.15;
            cursor: default;
            pointer-events: none;
        }
        
        .station.greyed-out .station-node {
            background: #f5f5f5;
            border-color: #e0e0e0;
            color: #d0d0d0;
        }
        
        .station.greyed-out .station-label {
            background: #fafafa;
            color: #d0d0d0;
            border-color: #f0f0f0;
        }
        
        .station.dependency-highlighted {
            z-index: 7;
        }
        
        .station.dependency-highlighted .station-node {
            box-shadow: 0 0 0 6px color-mix(in srgb, var(--track-color) 40%, transparent);
            transform: scale(1.1);
        }
        
        .station-node {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: white;
            border: 3px solid var(--track-color, var(--hpe-green));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.8rem;
            color: var(--hpe-gray);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            transition: all 0.2s;
        }
        
        .station.active .station-node {
            background: var(--track-color);
            color: white;
        }
        
        .station-label {
            margin-top: 0.5rem;
            background: white;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--hpe-gray);
            width: 140px;
            text-align: center;
            line-height: 1.2;
            border: 1px solid var(--hpe-border);
            transition: all 0.2s;
        }
        
        /* Detail Panel */
        .detail-panel {
            position: fixed;
            top: 0;
            right: -650px;
            width: 650px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 12px rgba(0,0,0,0.2);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .detail-panel.open {
            right: 0;
        }
        
        .detail-header {
            background: linear-gradient(135deg, #01A982 0%, #008567 100%);
            color: white;
            padding: 2rem;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            transition: background 0.2s;
        }
        
        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .back-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .detail-header h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        
        .detail-header .task-number {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .close-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .detail-content {
            padding: 2rem;
        }
        
        .detail-section {
            margin-bottom: 2rem;
        }
        
        .detail-section h3 {
            color: var(--hpe-gray);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .detail-section h3::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--hpe-green);
            border-radius: 2px;
        }
        
        .detail-section p {
            color: var(--text-primary);
            line-height: 1.7;
            font-size: 0.95rem;
            white-space: pre-wrap;
        }
        
        .detail-section ul {
            list-style: none;
            padding-left: 0;
        }
        
        .detail-section li {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--hpe-border);
        }
        
        .detail-section li:last-child {
            border-bottom: none;
        }
        
        .dependency-item {
            background: var(--hpe-light-gray);
            padding: 0.75rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            border-left: 3px solid var(--hpe-green);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .dependency-item:hover {
            background: #E8F5F1;
            transform: translateX(4px);
        }
        
        .dependency-item.linked {
            border-left-color: var(--hpe-green);
            background: #E8F5F1;
        }
        
        .dependency-item .dep-badge {
            display: inline-block;
            background: var(--hpe-green);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }
        
        .dependency-item.filtered-out {
            display: none;
        }
        
        .tag {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .tag-category {
            background: var(--hpe-green);
            color: white;
        }
        
        .tag-governance {
            background: var(--hpe-light-gray);
            color: var(--text-primary);
        }
        
        .scenario-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .scenario-badge {
            background: #E8F5F1;
            color: var(--hpe-green);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            border: 1px solid var(--hpe-green);
        }
        
        /* Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.1);
            display: none;
            z-index: 99;
            pointer-events: none;
        }
        
        .overlay.active {
            display: block;
        }
        
        /* When panel is open, dim non-connected stations */
        body.panel-open .station:not(.active):not(.dependency-highlighted) {
            opacity: 0.25;
        }
        
        body.panel-open .station:not(.active):not(.dependency-highlighted) .station-node {
            background: #f0f0f0;
            border-color: #ccc;
            color: #aaa;
        }
        
        /* Dim track rails except for the active track */
        body.panel-open .track-rail {
            opacity: 0.3;
        }
        
        body.panel-open .track.active-track .track-rail {
            opacity: 1;
        }
        
        /* Keep highlighted elements fully visible */
        body.panel-open .station.active,
        body.panel-open .station.dependency-highlighted {
            opacity: 1 !important;
            z-index: 250 !important;
        }
        
        body.panel-open .station.dependency-highlighted .station-node {
            box-shadow: 0 0 0 6px rgba(1, 169, 130, 0.4);
            transform: scale(1.05);
        }
        
        /* Hide non-highlighted connection lines when panel is open */
        body.panel-open .connection-line:not(.highlighted),
        body.panel-open .connection-arrow:not(.highlighted) {
            opacity: 0 !important;
            pointer-events: none;
        }
        
        body.panel-open .connection-line.highlighted {
            opacity: 1 !important;
            stroke-width: 6px !important;
            stroke: var(--connection-hover) !important;
        }
        
        body.panel-open .connection-arrow.highlighted {
            opacity: 1 !important;
            fill: var(--connection-hover) !important;
        }
        
        /* Ensure highlighted stations stay visible */
        body.panel-open .station.dependency-highlighted {
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        /* Off-screen dependency indicators */
        .offscreen-indicators {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 500;
            display: none;
        }
        
        body.panel-open .offscreen-indicators {
            display: block;
        }
        
        .offscreen-indicator {
            position: absolute;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.2);
            font-size: 0.85rem;
            font-weight: 600;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 501;
        }
        
        .offscreen-indicator:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
        }
        
        .offscreen-indicator.left {
            left: 10px;
            border-left: 4px solid var(--indicator-color);
        }
        
        .offscreen-indicator.left::before {
            content: '◀';
            color: var(--indicator-color);
        }
        
        .offscreen-indicator.right {
            right: 70px;
            border-right: 4px solid var(--indicator-color);
        }
        
        .offscreen-indicator.right::after {
            content: '▶';
            color: var(--indicator-color);
        }
        
        .offscreen-indicator .indicator-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.8rem;
            background: var(--indicator-color);
        }
        
        .offscreen-indicator .indicator-label {
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #333;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .detail-panel {
                width: 100%;
                right: -100%;
            }
            
            .container {
                padding: 1rem;
            }
            
            .subway-map {
                padding: 1rem;
                gap: 0.5rem;
            }
            
            .track {
                min-width: 120px;
            }
            
            .filter-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Scroll hint */
        .scroll-hint {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--hpe-green);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 0.9rem;
            font-weight: 600;
            opacity: 0.9;
            pointer-events: none;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 0.9; transform: translateY(0); }
        }
        
        /* List View Styles */
        .list-view-wrapper {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
            margin-top: 1rem;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
        }
        
        .task-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .task-table thead {
            background: linear-gradient(135deg, var(--hpe-green) 0%, var(--hpe-dark-green) 100%);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .task-table th {
            padding: 1rem 0.75rem;
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .task-table td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--hpe-border);
            vertical-align: top;
        }
        
        .task-table tbody tr:hover {
            background: #f8fffe;
        }
        
        .task-table tbody tr.filtered-out {
            display: none;
        }
        
        .task-table .task-num {
            font-weight: 700;
            color: var(--hpe-green);
            white-space: nowrap;
        }
        
        .task-table .category-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            white-space: nowrap;
        }
        
        .task-table .deliverable-cell {
            font-weight: 600;
            max-width: 200px;
        }
        
        .task-table .desc-cell {
            max-width: 300px;
            line-height: 1.5;
        }
        
        .task-table .desc-cell ul,
        .task-table .desc-cell ol {
            margin: 0.5rem 0;
            padding-left: 1.25rem;
        }
        
        .task-table .owner-cell {
            white-space: nowrap;
        }
        
        .task-table .deps-cell {
            max-width: 180px;
        }
        
        .task-table .dep-link {
            display: block;
            color: #333;
            padding: 0.35rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            margin: 0.2rem 0;
            cursor: pointer;
            text-decoration: none;
            border-left: 3px solid #425563;
            transition: all 0.2s;
        }
        
        .task-table .dep-link strong {
            margin-right: 0.25rem;
        }
        
        .task-table .dep-link:hover {
            filter: brightness(0.95);
            transform: translateX(2px);
        }
        
        .task-table .dep-link:hover strong {
            color: white;
        }
        
        .task-table .action-btn {
            padding: 0.4rem 0.75rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .task-table .edit-btn {
            background: #E8F5F1;
            color: var(--hpe-green);
        }
        
        .task-table .edit-btn:hover {
            background: var(--hpe-green);
            color: white;
        }
        
        /* PIN Modal */
        .pin-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 2500;
            align-items: center;
            justify-content: center;
        }
        
        .pin-modal.active {
            display: flex;
        }
        
        .pin-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .pin-modal-header {
            background: linear-gradient(135deg, #425563 0%, #2d3a44 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
        }
        
        .pin-modal-header h2 {
            font-size: 1.25rem;
            margin: 0;
        }
        
        .pin-modal-body {
            padding: 2rem;
            text-align: center;
        }
        
        .pin-modal-body p {
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }
        
        .pin-input {
            width: 100%;
            padding: 1rem;
            font-size: 1.5rem;
            text-align: center;
            letter-spacing: 0.5rem;
            border: 2px solid var(--hpe-border);
            border-radius: 8px;
            font-family: monospace;
        }
        
        .pin-input:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .pin-error {
            display: none;
            margin-top: 1rem;
            padding: 0.75rem;
            background: #ffebee;
            color: #c62828;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .pin-modal-footer {
            padding: 1rem 2rem 2rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        
        .pin-modal-footer button {
            padding: 0.75rem 2rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
        }
        
        .pin-cancel-btn {
            background: white;
            border: 2px solid var(--hpe-border);
            color: var(--text-secondary);
        }
        
        .pin-cancel-btn:hover {
            border-color: var(--hpe-gray);
            color: var(--hpe-gray);
        }
        
        .pin-submit-btn {
            background: var(--hpe-green);
            border: 2px solid var(--hpe-green);
            color: white;
        }
        
        .pin-submit-btn:hover {
            background: var(--hpe-dark-green);
            border-color: var(--hpe-dark-green);
        }
        
        /* Edit Modal */
        .edit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .edit-modal.active {
            display: flex;
        }
        
        .edit-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .edit-modal-header {
            background: linear-gradient(135deg, var(--hpe-green) 0%, var(--hpe-dark-green) 100%);
            color: white;
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
        }
        
        .edit-modal-header h2 {
            font-size: 1.25rem;
            margin: 0;
        }
        
        .edit-modal-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .edit-modal-close:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .edit-modal-body {
            padding: 1.5rem;
        }
        
        .edit-field {
            margin-bottom: 1.25rem;
        }
        
        .edit-field label {
            display: block;
            font-weight: 600;
            color: var(--hpe-gray);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .edit-field input,
        .edit-field textarea,
        .edit-field select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        
        .edit-field input:focus,
        .edit-field textarea:focus,
        .edit-field select:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .edit-field textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        .edit-field .html-hint {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        
        .edit-field .html-hint code {
            background: var(--hpe-light-gray);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .edit-field-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .edit-modal-footer {
            padding: 1rem 1.5rem;
            background: var(--hpe-light-gray);
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            position: sticky;
            bottom: 0;
        }
        
        .edit-modal-footer button {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .edit-cancel-btn {
            background: white;
            border: 2px solid var(--hpe-border);
            color: var(--text-secondary);
        }
        
        .edit-cancel-btn:hover {
            border-color: var(--hpe-gray);
            color: var(--hpe-gray);
        }
        
        .edit-save-btn {
            background: var(--hpe-green);
            border: 2px solid var(--hpe-green);
            color: white;
        }
        
        .edit-save-btn:hover {
            background: var(--hpe-dark-green);
            border-color: var(--hpe-dark-green);
        }
        
        .export-btn {
            background: #FF8C00;
            border: 2px solid #FF8C00;
            color: white;
            margin-right: auto;
        }
        
        .export-btn:hover {
            background: #E67E00;
            border-color: #E67E00;
        }
        
        .list-actions {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .list-actions button {
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .export-csv-btn {
            background: var(--hpe-green);
            border: 2px solid var(--hpe-green);
            color: white;
        }
        
        .export-csv-btn:hover {
            background: var(--hpe-dark-green);
        }
        
        /* Rich Text Editor */
        .rich-editor-toolbar {
            display: flex;
            gap: 0.25rem;
            padding: 0.5rem;
            background: var(--hpe-light-gray);
            border: 2px solid var(--hpe-border);
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            flex-wrap: wrap;
        }
        
        .toolbar-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: var(--hpe-gray);
            transition: all 0.2s;
        }
        
        .toolbar-btn:hover {
            background: var(--hpe-green);
            color: white;
        }
        
        .toolbar-btn:active {
            transform: scale(0.95);
        }
        
        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--hpe-border);
            margin: 4px 0.5rem;
        }
        
        .rich-editor {
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 0 0 6px 6px;
            font-size: 0.9rem;
            font-family: inherit;
            line-height: 1.6;
            background: white;
        }
        
        .rich-editor:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .rich-editor ul, .rich-editor ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        
        .rich-editor li {
            margin: 0.25rem 0;
        }
        
        .rich-editor a {
            color: var(--hpe-green);
        }
        
        /* Dependency Picker */
        .dependency-picker {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .dependency-search-wrapper {
            position: relative;
        }
        
        .dependency-search {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
        }
        
        .dependency-search:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .dependency-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 250px;
            overflow-y: auto;
            background: white;
            border: 2px solid var(--hpe-green);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
        }
        
        .dependency-dropdown.active {
            display: block;
        }
        
        .dependency-option {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--hpe-border);
            transition: background 0.15s;
        }
        
        .dependency-option:hover {
            background: #E8F5F1;
        }
        
        .dependency-option:last-child {
            border-bottom: none;
        }
        
        .dependency-option .task-num {
            font-weight: 700;
            color: var(--hpe-green);
            margin-right: 0.5rem;
        }
        
        .dependency-option .deliverable-name {
            color: var(--text-primary);
        }
        
        .dependency-option .category-tag {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.15rem 0.4rem;
            border-radius: 8px;
            background: var(--hpe-light-gray);
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }
        
        .dependency-option.already-selected {
            opacity: 0.5;
            background: var(--hpe-light-gray);
        }
        
        .dependency-option.already-selected::after {
            content: '✓ Added';
            float: right;
            color: var(--hpe-green);
            font-size: 0.8rem;
        }
        
        .selected-dependencies {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            min-height: 40px;
            padding: 0.5rem;
            background: var(--hpe-light-gray);
            border-radius: 6px;
        }
        
        .selected-dep-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            background: white;
            border: 2px solid var(--hpe-green);
            border-radius: 20px;
            font-size: 0.85rem;
        }
        
        .selected-dep-tag .dep-num {
            font-weight: 700;
            color: var(--hpe-green);
        }
        
        .selected-dep-tag .dep-name {
            color: var(--text-primary);
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .selected-dep-tag .remove-dep {
            width: 18px;
            height: 18px;
            border: none;
            background: var(--hpe-light-gray);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .selected-dep-tag .remove-dep:hover {
            background: #ffebee;
            color: #c62828;
        }
        
        .no-deps-message {
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-style: italic;
        }
        
        /* Role Picker (Where Work Gets Done) */
        .role-picker {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .role-search-wrapper {
            position: relative;
        }
        
        .role-search {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
        }
        
        .role-search:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .role-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 2px solid var(--hpe-green);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
        }
        
        .role-dropdown.active {
            display: block;
        }
        
        .role-option {
            padding: 0.6rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--hpe-border);
            font-size: 0.9rem;
            transition: background 0.15s;
        }
        
        .role-option:hover {
            background: #E8F5F1;
        }
        
        .role-option:last-child {
            border-bottom: none;
        }
        
        .role-option.already-selected {
            opacity: 0.5;
            background: var(--hpe-light-gray);
        }
        
        .role-option.already-selected::after {
            content: '✓ Added';
            float: right;
            color: var(--hpe-green);
            font-size: 0.8rem;
        }
        
        .role-option.add-new {
            color: var(--hpe-green);
            font-weight: 600;
            font-style: italic;
        }
        
        .selected-roles {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            min-height: 40px;
            padding: 0.5rem;
            background: var(--hpe-light-gray);
            border-radius: 6px;
        }
        
        .selected-role-tag {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: white;
            border-left: 3px solid var(--hpe-green);
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .selected-role-tag .role-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .selected-role-tag .remove-role {
            width: 20px;
            height: 20px;
            border: none;
            background: var(--hpe-light-gray);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .selected-role-tag .remove-role:hover {
            background: #ffebee;
            color: #c62828;
        }
        
        .no-roles-message {
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-style: italic;
        }
        
        /* Autocomplete Dropdown */
        .autocomplete-wrapper {
            position: relative;
        }
        
        .autocomplete-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
        }
        
        .autocomplete-input:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .autocomplete-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 2px solid var(--hpe-green);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
        }
        
        .autocomplete-dropdown.active {
            display: block;
        }
        
        .autocomplete-option {
            padding: 0.6rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--hpe-border);
            font-size: 0.9rem;
        }
        
        .autocomplete-option:hover {
            background: #E8F5F1;
        }
        
        .autocomplete-option:last-child {
            border-bottom: none;
        }
        
        .autocomplete-option.add-new {
            color: var(--hpe-green);
            font-weight: 600;
            font-style: italic;
        }
        
        /* Links Editor */
        .links-editor {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .link-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 0.5rem;
            align-items: center;
            padding: 0.5rem;
            background: var(--hpe-light-gray);
            border-radius: 6px;
        }
        
        .link-row input {
            padding: 0.5rem;
            border: 1px solid var(--hpe-border);
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        .link-row input:focus {
            outline: none;
            border-color: var(--hpe-green);
        }
        
        .link-row .remove-link-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: #ffebee;
            color: #c62828;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .link-row .remove-link-btn:hover {
            background: #c62828;
            color: white;
        }
        
        .add-link-btn {
            padding: 0.5rem 1rem;
            border: 2px dashed var(--hpe-border);
            background: transparent;
            color: var(--hpe-green);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        
        .add-link-btn:hover {
            border-color: var(--hpe-green);
            background: #E8F5F1;
        }
        
        .link-row-header {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            padding: 0 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .link-row-header span:last-child {
            width: 28px;
        }
    </style>
        
        /* ========================================
           SMARTSHEET INTEGRATION STYLES
           ======================================== */
        
        /* Sync Status Bar */
        .sync-status-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            margin-top: 0.5rem;
        }
        
        .sync-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .sync-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            transition: background 0.3s;
        }
        
        .sync-dot.connected {
            background: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
        }
        
        .sync-dot.syncing {
            background: #FFA726;
            animation: pulse 1s infinite;
        }
        
        .sync-dot.error {
            background: #EF5350;
        }
        
        .sync-dot.offline {
            background: #888;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .sync-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: auto;
        }
        
        .sync-btn {
            padding: 0.35rem 0.75rem;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
            transition: all 0.2s;
        }
        
        .sync-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }
        
        .sync-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .sync-btn.spinning svg {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            100% { transform: rotate(360deg); }
        }
        
        /* Smartsheet Config Modal */
        .config-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2500;
            align-items: center;
            justify-content: center;
        }
        
        .config-modal.active {
            display: flex;
        }
        
        .config-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .config-modal-header {
            background: linear-gradient(135deg, #1976D2 0%, #0D47A1 100%);
            color: white;
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
        }
        
        .config-modal-header h2 {
            font-size: 1.25rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .config-modal-body {
            padding: 1.5rem;
        }
        
        .config-field {
            margin-bottom: 1.25rem;
        }
        
        .config-field label {
            display: block;
            font-weight: 600;
            color: var(--hpe-gray);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .config-field input,
        .config-field select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--hpe-border);
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
        }
        
        .config-field input:focus,
        .config-field select:focus {
            outline: none;
            border-color: #1976D2;
        }
        
        .config-field .help-text {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        
        .config-status {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .config-status.success {
            background: #E8F5E9;
            color: #2E7D32;
            border: 1px solid #A5D6A7;
        }
        
        .config-status.error {
            background: #FFEBEE;
            color: #C62828;
            border: 1px solid #EF9A9A;
        }
        
        .config-status.info {
            background: #E3F2FD;
            color: #1565C0;
            border: 1px solid #90CAF9;
        }
        
        .config-modal-footer {
            padding: 1rem 1.5rem;
            background: var(--hpe-light-gray);
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            border-radius: 0 0 12px 12px;
        }
        
        .config-modal-footer button {
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .config-test-btn {
            background: white;
            border: 2px solid #1976D2;
            color: #1976D2;
        }
        
        .config-test-btn:hover {
            background: #E3F2FD;
        }
        
        .config-save-btn {
            background: #1976D2;
            border: 2px solid #1976D2;
            color: white;
        }
        
        .config-save-btn:hover {
            background: #1565C0;
            border-color: #1565C0;
        }
        
        .config-cancel-btn {
            background: white;
            border: 2px solid var(--hpe-border);
            color: var(--text-secondary);
        }
        
        .config-cancel-btn:hover {
            border-color: var(--hpe-gray);
            color: var(--hpe-gray);
        }
        
        /* Last Sync Info */
        .last-sync-info {
            font-size: 0.75rem;
            opacity: 0.8;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.9);
            z-index: 3000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #E0E0E0;
            border-top-color: var(--hpe-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loading-text {
            margin-top: 1rem;
            font-size: 1rem;
            color: var(--hpe-gray);
        }
        
        /* Auto-refresh toggle */
        .auto-refresh-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
        }
        
        .auto-refresh-toggle input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        
        /* Data source indicator */
        .data-source-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
        }
        
        /* Edit modal - save to Smartsheet indicator */
        .save-destination {
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }
        
        .save-destination.smartsheet {
            color: #1976D2;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Loading data from Smartsheet...</div>
    </div>

    <div class="header">
        <h1>HPE GreenLake Ready Process Navigator</h1>
        <p>Interactive Process Flow with Dependency Connections | Filter by scenario | Hover over tasks to see dependencies</p>
        
        <!-- Sync Status Bar -->
        <div class="sync-status-bar" id="syncStatusBar">
            <div class="sync-indicator">
                <div class="sync-dot" id="syncDot"></div>
                <span id="syncStatusText">Not connected</span>
                <span class="data-source-badge" id="dataSourceBadge">Local Data</span>
            </div>
            <div class="last-sync-info" id="lastSyncInfo"></div>
            <div class="sync-actions">
                <label class="auto-refresh-toggle">
                    <input type="checkbox" id="autoRefreshToggle" onchange="toggleAutoRefresh(this.checked)">
                    <span>Auto-refresh</span>
                </label>
                <button class="sync-btn" id="refreshBtn" onclick="refreshFromSmartsheet()" title="Refresh data from Smartsheet">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M23 4v6h-6M1 20v-6h6"/>
                        <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
                    </svg>
                    Refresh
                </button>
                <button class="sync-btn" id="configBtn" onclick="openConfigModal()" title="Configure Smartsheet Connection">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/>
                    </svg>
                    Settings
                </button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="controls">
            <div class="view-toggle">
                <button class="view-btn active" id="mapViewBtn" onclick="switchView('map')">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4m-10-10h4m12 0h4m-3.5-6.5l-2.8 2.8m-5.4 5.4l-2.8 2.8m0-11l2.8 2.8m5.4 5.4l2.8 2.8"/>
                    </svg>
                    Map View
                </button>
                <button class="view-btn" id="listViewBtn" onclick="switchView('list')">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                    List View
                </button>
            </div>
            <label id="connectionsToggle">
                <input type="checkbox" id="showConnections" checked onchange="toggleConnections(this.checked)">
                <span>Show Dependency Connections</span>
            </label>
            <button class="show-all-btn" id="showAllBtn" onclick="showAll()">
                ↺ Show All Tasks
            </button>
        </div>
        
        <!-- Global Search -->
        <div class="global-search-wrapper">
            <div class="global-search-box">
                <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/>
                </svg>
                <input type="text" id="globalSearch" class="global-search-input" placeholder="Search tasks, deliverables, descriptions, owners..." oninput="handleGlobalSearch(this.value)">
                <button class="clear-search-btn" id="clearSearchBtn" onclick="clearGlobalSearch()" style="display: none;">×</button>
            </div>
            <div class="search-results-count" id="searchResultsCount"></div>
        </div>
        
        <!-- Collapsible Filters -->
        <div class="filters-container">
            <button class="filters-toggle" id="filtersToggle" onclick="toggleFiltersPanel()">
                <span class="filters-toggle-text">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
                    </svg>
                    Filters
                </span>
                <span class="filters-badge" id="filtersBadge" style="display: none;">0</span>
                <svg class="filters-chevron" id="filtersChevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"/>
                </svg>
            </button>
            
            <div class="filters" id="filtersPanel">
                <div class="filter-section">
                    <h3>Filter by Scenario</h3>
                    <div class="filter-grid" id="filterGrid">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>
                
                <div class="filter-section">
                    <h3>Filter by Category</h3>
                    <div class="category-filter-grid" id="categoryFilterGrid">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>
                
                <div class="filter-actions">
                    <button class="clear-filters" id="clearFilters">Clear all filters</button>
                    <label class="hide-empty-toggle">
                        <input type="checkbox" id="hideEmptyTracks" checked onchange="toggleEmptyTracks(this.checked)">
                        <span>Condense view when filtered</span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Map View -->
        <div id="mapViewContainer">
            <div class="scroll-wrapper-top" id="scrollTop">
                <div class="scroll-wrapper-top-inner" id="scrollTopInner"></div>
            </div>
            
            <div class="subway-map-container" id="subwayMapContainer">
                <div class="subway-map" id="subwayMap">
                    <!-- Tracks and SVG will be populated by JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- List View -->
        <div id="listViewContainer" style="display: none;">
            <div class="list-search-wrapper">
                <div class="list-search-box">
                    <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/>
                    </svg>
                    <input type="text" id="listSearch" class="list-search" placeholder="Filter list..." oninput="filterListView(this.value)">
                </div>
                <div class="list-sort-controls">
                    <label>Sort by:</label>
                    <select id="listSort" onchange="sortListView(this.value)">
                        <option value="taskNumber">Task Number</option>
                        <option value="category">Category</option>
                        <option value="deliverable">Deliverable</option>
                        <option value="owner">Owner</option>
                    </select>
                </div>
                <button class="export-all-btn" onclick="exportAllToCSV()">
                    📥 Export All to CSV
                </button>
            </div>
            <div class="list-view" id="listView">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <div class="scroll-wrapper-bottom" id="scrollBottom">
        <div class="scroll-wrapper-bottom-inner" id="scrollBottomInner"></div>
    </div>
    
    <div class="overlay" id="overlay"></div>
    
    <div class="offscreen-indicators" id="offscreenIndicators">
        <!-- Will be populated by JavaScript when panel is open -->
    </div>
    
    <div class="detail-panel" id="detailPanel">
        <div class="detail-header">
            <button class="close-btn" id="closeBtn">&times;</button>
            <div id="backButtonContainer"></div>
            <h2 id="detailTitle">Task Details</h2>
            <div class="task-number" id="detailTaskNumber"></div>
        </div>
        <div class="detail-content" id="detailContent">
            <!-- Will be populated by JavaScript -->
        </div>
    </div>
    
    <!-- PIN Modal -->
    <div class="pin-modal" id="pinModal">
        <div class="pin-modal-content">
            <div class="pin-modal-header">
                <h2>🔒 Edit Access Required</h2>
            </div>
            <div class="pin-modal-body">
                <p>Enter PIN to enable editing:</p>
                <input type="hidden" id="pinTaskNumber">
                <input type="password" id="pinInput" class="pin-input" maxlength="10" placeholder="Enter PIN">
                <div class="pin-error" id="pinError">Incorrect PIN. Please try again.</div>
            </div>
            <div class="pin-modal-footer">
                <button class="pin-cancel-btn" onclick="closePinModal()">Cancel</button>
                <button class="pin-submit-btn" onclick="verifyPin()">Unlock</button>
            </div>
        </div>
    </div>
    
    <!-- Smartsheet Configuration Modal -->
    <div class="config-modal" id="configModal">
        <div class="config-modal-content">
            <div class="config-modal-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="9" y1="21" x2="9" y2="9"/>
                    </svg>
                    Smartsheet Connection
                </h2>
                <button class="edit-modal-close" onclick="closeConfigModal()">&times;</button>
            </div>
            <div class="config-modal-body">
                <div class="config-status" id="configStatus" style="display: none;"></div>
                
                <div class="config-field">
                    <label for="configProxyUrl">Azure Proxy URL</label>
                    <input type="url" id="configProxyUrl" placeholder="https://your-function.azurewebsites.net/api/smartsheet-proxy">
                    <div class="help-text">The URL of your Azure Function that proxies Smartsheet API calls</div>
                </div>
                
                <div class="config-field">
                    <label for="configSheetId">Smartsheet ID</label>
                    <input type="text" id="configSheetId" placeholder="1234567890123456">
                    <div class="help-text">The ID of your Smartsheet (found in the sheet URL or Sheet Properties)</div>
                </div>
                
                <div class="config-field">
                    <label for="configFunctionKey">Function Key (Optional)</label>
                    <input type="password" id="configFunctionKey" placeholder="Your Azure Function key">
                    <div class="help-text">If your Azure Function requires a function key for authentication</div>
                </div>
                
                <div class="config-field">
                    <label for="configRefreshInterval">Auto-refresh Interval (minutes)</label>
                    <select id="configRefreshInterval">
                        <option value="0">Disabled</option>
                        <option value="1">1 minute</option>
                        <option value="5" selected>5 minutes</option>
                        <option value="10">10 minutes</option>
                        <option value="30">30 minutes</option>
                    </select>
                </div>
            </div>
            <div class="config-modal-footer">
                <button class="config-cancel-btn" onclick="closeConfigModal()">Cancel</button>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="config-test-btn" onclick="testSmartsheetConnection()">Test Connection</button>
                    <button class="config-save-btn" onclick="saveSmartsheetConfig()">Save & Connect</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Modal -->
    <div class="edit-modal" id="editModal">
        <div class="edit-modal-content">
            <div class="edit-modal-header">
                <h2 id="editModalTitle">Edit Task</h2>
                <button class="edit-modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <div class="edit-modal-body">
                <input type="hidden" id="editTaskNumber">
                
                <div class="edit-field-row">
                    <div class="edit-field">
                        <label for="editDeliverable">Deliverable</label>
                        <input type="text" id="editDeliverable">
                    </div>
                    <div class="edit-field">
                        <label for="editCategory">Category</label>
                        <select id="editCategory">
                            <!-- Will be populated -->
                        </select>
                    </div>
                </div>
                
                <div class="edit-field">
                    <label>Description</label>
                    <div class="rich-editor-toolbar">
                        <button type="button" class="toolbar-btn" onclick="formatText('bold')" title="Bold (Ctrl+B)"><b>B</b></button>
                        <button type="button" class="toolbar-btn" onclick="formatText('italic')" title="Italic (Ctrl+I)"><i>I</i></button>
                        <button type="button" class="toolbar-btn" onclick="formatText('underline')" title="Underline (Ctrl+U)"><u>U</u></button>
                        <span class="toolbar-divider"></span>
                        <button type="button" class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Bullet List">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><circle cx="4" cy="6" r="2"/><circle cx="4" cy="12" r="2"/><circle cx="4" cy="18" r="2"/><rect x="8" y="5" width="14" height="2"/><rect x="8" y="11" width="14" height="2"/><rect x="8" y="17" width="14" height="2"/></svg>
                        </button>
                        <button type="button" class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Numbered List">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><text x="2" y="8" font-size="8">1.</text><text x="2" y="14" font-size="8">2.</text><text x="2" y="20" font-size="8">3.</text><rect x="10" y="5" width="12" height="2"/><rect x="10" y="11" width="12" height="2"/><rect x="10" y="17" width="12" height="2"/></svg>
                        </button>
                        <span class="toolbar-divider"></span>
                        <button type="button" class="toolbar-btn" onclick="insertLink()" title="Insert Link">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg>
                        </button>
                        <button type="button" class="toolbar-btn" onclick="clearFormatting()" title="Clear Formatting">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/><line x1="3" y1="21" x2="21" y2="3" stroke="red" stroke-width="2"/></svg>
                        </button>
                    </div>
                    <div id="editDescriptionEditor" class="rich-editor" contenteditable="true"></div>
                    <input type="hidden" id="editDescription">
                </div>
                
                <div class="edit-field-row">
                    <div class="edit-field">
                        <label for="editOwner">Owner</label>
                        <div class="autocomplete-wrapper">
                            <input type="text" id="editOwner" class="autocomplete-input" placeholder="Type or select..." oninput="filterAutocomplete('owner', this.value)" onfocus="showAutocomplete('owner')">
                            <div class="autocomplete-dropdown" id="ownerDropdown"></div>
                        </div>
                    </div>
                    <div class="edit-field">
                        <label for="editInformed">Informed Parties</label>
                        <div class="autocomplete-wrapper">
                            <input type="text" id="editInformed" class="autocomplete-input" placeholder="Type or select..." oninput="filterAutocomplete('informed', this.value)" onfocus="showAutocomplete('informed')">
                            <div class="autocomplete-dropdown" id="informedDropdown"></div>
                        </div>
                    </div>
                </div>
                
                <div class="edit-field">
                    <label>Where Work Gets Done (by Role)</label>
                    <div class="role-picker">
                        <div class="role-search-wrapper">
                            <input type="text" id="roleSearch" class="role-search" placeholder="Search or add role..." oninput="searchRoles(this.value)" onfocus="showRoleDropdown()">
                            <div class="role-dropdown" id="roleDropdown">
                                <!-- Will be populated by JavaScript -->
                            </div>
                        </div>
                        <div class="selected-roles" id="selectedRoles">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>
                    <input type="hidden" id="editWhereWorkDone">
                </div>
                
                <div class="edit-field">
                    <label>Dependencies</label>
                    <div class="dependency-picker">
                        <div class="dependency-search-wrapper">
                            <input type="text" id="dependencySearch" class="dependency-search" placeholder="Search by task # or deliverable name..." oninput="searchDependencies(this.value)" onfocus="showDependencyDropdown()">
                            <div class="dependency-dropdown" id="dependencyDropdown">
                                <!-- Will be populated by JavaScript -->
                            </div>
                        </div>
                        <div class="selected-dependencies" id="selectedDependencies">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>
                    <input type="hidden" id="editDependencies">
                </div>
                
                <div class="edit-field">
                    <label>Links</label>
                    <div class="links-editor" id="linksEditor">
                        <!-- Will be populated by JavaScript -->
                    </div>
                    <button type="button" class="add-link-btn" onclick="addLinkRow()">+ Add Link</button>
                    <input type="hidden" id="editLinks">
                </div>
            </div>
            <div class="edit-modal-footer">
                <div class="save-destination" id="saveDestination">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    <span id="saveDestinationText">Saving locally</span>
                </div>
                <button class="export-btn" onclick="exportSingleTask()">📋 Copy as CSV Row</button>
                <button class="edit-cancel-btn" onclick="closeEditModal()">Cancel</button>
                <button class="edit-save-btn" onclick="saveTaskEdit()">Save Changes</button>
            </div>
        </div>
    </div>
    
    <script>
        // ========================================
        // SMARTSHEET INTEGRATION MODULE
        // ========================================
        
        // Configuration storage
        const STORAGE_KEY = 'glReadySmartsheetConfig';
        let smartsheetConfig = {
            proxyUrl: '',
            sheetId: '',
            functionKey: '',
            refreshInterval: 5,
            lastSync: null,
            connected: false
        };
        
        // Smartsheet data cache
        let smartsheetColumnMapping = {};
        let autoRefreshInterval = null;
        
        // Data arrays (will be populated from Smartsheet or fallback data)
        let processDataRaw = [];
        let dependencyConnections = [];
        
        // Load configuration from localStorage
        function loadSmartsheetConfig() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    smartsheetConfig = { ...smartsheetConfig, ...JSON.parse(saved) };
                    
                    // Populate form fields
                    document.getElementById('configProxyUrl').value = smartsheetConfig.proxyUrl || '';
                    document.getElementById('configSheetId').value = smartsheetConfig.sheetId || '';
                    document.getElementById('configFunctionKey').value = smartsheetConfig.functionKey || '';
                    document.getElementById('configRefreshInterval').value = smartsheetConfig.refreshInterval || 5;
                }
            } catch (e) {
                console.error('Error loading Smartsheet config:', e);
            }
        }
        
        // Save configuration to localStorage
        function saveSmartsheetConfigToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(smartsheetConfig));
            } catch (e) {
                console.error('Error saving Smartsheet config:', e);
            }
        }
        
        // Update sync status UI
        function updateSyncStatus(status, message, isError = false) {
            const dot = document.getElementById('syncDot');
            const text = document.getElementById('syncStatusText');
            const badge = document.getElementById('dataSourceBadge');
            const lastSyncInfo = document.getElementById('lastSyncInfo');
            
            dot.className = 'sync-dot ' + status;
            text.textContent = message;
            
            if (status === 'connected') {
                badge.textContent = 'Smartsheet';
                badge.style.background = 'rgba(25, 118, 210, 0.3)';
                
                // Update save destination in edit modal
                const saveDestText = document.getElementById('saveDestinationText');
                const saveDest = document.getElementById('saveDestination');
                if (saveDestText && saveDest) {
                    saveDestText.textContent = 'Saving to Smartsheet';
                    saveDest.classList.add('smartsheet');
                }
            } else if (status === 'offline') {
                badge.textContent = 'Local Data';
                badge.style.background = 'rgba(255,255,255,0.2)';
                
                const saveDestText = document.getElementById('saveDestinationText');
                const saveDest = document.getElementById('saveDestination');
                if (saveDestText && saveDest) {
                    saveDestText.textContent = 'Saving locally';
                    saveDest.classList.remove('smartsheet');
                }
            }
            
            if (smartsheetConfig.lastSync) {
                const lastSync = new Date(smartsheetConfig.lastSync);
                lastSyncInfo.textContent = `Last sync: ${lastSync.toLocaleTimeString()}`;
            }
        }
        
        // Show loading overlay
        function showLoading(message = 'Loading...') {
            document.getElementById('loadingText').textContent = message;
            document.getElementById('loadingOverlay').classList.add('active');
        }
        
        // Hide loading overlay
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }
        
        // Open configuration modal
        function openConfigModal() {
            loadSmartsheetConfig();
            document.getElementById('configModal').classList.add('active');
            hideConfigStatus();
        }
        
        // Close configuration modal
        function closeConfigModal() {
            document.getElementById('configModal').classList.remove('active');
        }
        
        // Show config status message
        function showConfigStatus(message, type = 'info') {
            const status = document.getElementById('configStatus');
            status.textContent = message;
            status.className = 'config-status ' + type;
            status.style.display = 'flex';
        }
        
        // Hide config status message
        function hideConfigStatus() {
            document.getElementById('configStatus').style.display = 'none';
        }
        
        // Build proxy URL with parameters
        function buildProxyUrl(action, params = {}) {
            const baseUrl = smartsheetConfig.proxyUrl;
            const url = new URL(baseUrl);
            url.searchParams.set('action', action);
            
            // Add sheet ID
            if (smartsheetConfig.sheetId) {
                url.searchParams.set('sheetId', smartsheetConfig.sheetId);
            }
            
            // Add function key if present
            if (smartsheetConfig.functionKey) {
                url.searchParams.set('code', smartsheetConfig.functionKey);
            }
            
            // Add additional params
            Object.entries(params).forEach(([key, value]) => {
                url.searchParams.set(key, value);
            });
            
            return url.toString();
        }
        
        // Test Smartsheet connection
        async function testSmartsheetConnection() {
            const proxyUrl = document.getElementById('configProxyUrl').value.trim();
            const sheetId = document.getElementById('configSheetId').value.trim();
            const functionKey = document.getElementById('configFunctionKey').value.trim();
            
            if (!proxyUrl || !sheetId) {
                showConfigStatus('Please enter Proxy URL and Sheet ID', 'error');
                return;
            }
            
            showConfigStatus('Testing connection...', 'info');
            
            try {
                // Temporarily set config for test
                const tempConfig = { proxyUrl, sheetId, functionKey };
                
                const url = new URL(proxyUrl);
                url.searchParams.set('action', 'getSheetInfo');
                url.searchParams.set('sheetId', sheetId);
                if (functionKey) {
                    url.searchParams.set('code', functionKey);
                }
                
                const response = await fetch(url.toString());
                const data = await response.json();
                
                if (data.success) {
                    showConfigStatus(`✓ Connected to "${data.sheetName}" (${data.columns.length} columns)`, 'success');
                } else {
                    showConfigStatus(`Connection failed: ${data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showConfigStatus(`Connection error: ${error.message}`, 'error');
            }
        }
        
        // Save Smartsheet configuration and connect
        async function saveSmartsheetConfig() {
            const proxyUrl = document.getElementById('configProxyUrl').value.trim();
            const sheetId = document.getElementById('configSheetId').value.trim();
            const functionKey = document.getElementById('configFunctionKey').value.trim();
            const refreshInterval = parseInt(document.getElementById('configRefreshInterval').value) || 0;
            
            if (!proxyUrl || !sheetId) {
                showConfigStatus('Please enter Proxy URL and Sheet ID', 'error');
                return;
            }
            
            // Save configuration
            smartsheetConfig = {
                ...smartsheetConfig,
                proxyUrl,
                sheetId,
                functionKey,
                refreshInterval
            };
            
            saveSmartsheetConfigToStorage();
            closeConfigModal();
            
            // Try to connect and fetch data
            await refreshFromSmartsheet();
            
            // Setup auto-refresh if enabled
            setupAutoRefresh();
        }
        
        // Fetch data from Smartsheet
        async function refreshFromSmartsheet() {
            if (!smartsheetConfig.proxyUrl || !smartsheetConfig.sheetId) {
                updateSyncStatus('offline', 'Not configured');
                return false;
            }
            
            updateSyncStatus('syncing', 'Syncing...');
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.classList.add('spinning');
            refreshBtn.disabled = true;
            
            try {
                const url = buildProxyUrl('getSheet');
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Store column mapping for updates
                    smartsheetColumnMapping = data.columnMapping || {};
                    
                    // Transform and store data
                    processDataRaw = data.data;
                    
                    // Regenerate dependency connections from the data
                    dependencyConnections = generateDependencyConnections(processDataRaw);
                    
                    // Update sync status
                    smartsheetConfig.lastSync = new Date().toISOString();
                    smartsheetConfig.connected = true;
                    saveSmartsheetConfigToStorage();
                    
                    updateSyncStatus('connected', 'Connected');
                    
                    // Re-render views
                    renderFilters();
                    if (currentView === 'list') {
                        renderListView();
                    } else {
                        renderSubwayMap();
                    }
                    
                    showToast(`✓ Synced ${processDataRaw.length} tasks from Smartsheet`);
                    return true;
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
            } catch (error) {
                console.error('Smartsheet sync error:', error);
                updateSyncStatus('error', 'Sync failed');
                showToast('Sync failed: ' + error.message, true);
                return false;
            } finally {
                refreshBtn.classList.remove('spinning');
                refreshBtn.disabled = false;
            }
        }
        
        // Save task to Smartsheet
        async function saveTaskToSmartsheet(task, updates) {
            if (!smartsheetConfig.connected || !task.rowId) {
                return false;
            }
            
            try {
                const url = buildProxyUrl('updateRow');
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sheetId: smartsheetConfig.sheetId,
                        rowId: task.rowId,
                        updates: updates,
                        columnMapping: smartsheetColumnMapping,
                        modifierEmail: '' // Can be populated if user auth is implemented
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    smartsheetConfig.lastSync = new Date().toISOString();
                    saveSmartsheetConfigToStorage();
                    updateSyncStatus('connected', 'Connected');
                    return true;
                } else {
                    throw new Error(data.error || 'Update failed');
                }
            } catch (error) {
                console.error('Smartsheet update error:', error);
                updateSyncStatus('error', 'Update failed');
                showToast('Failed to save to Smartsheet: ' + error.message, true);
                return false;
            }
        }
        
        // Generate dependency connections from task data
        function generateDependencyConnections(tasks) {
            const connections = [];
            const deliverableToTask = {};
            
            // Build lookup map
            tasks.forEach(task => {
                if (task.deliverable) {
                    deliverableToTask[task.deliverable.trim()] = task.taskNumber;
                }
            });
            
            // Generate connections
            tasks.forEach(task => {
                if (task.dependencies) {
                    const deps = task.dependencies.split('\n').filter(d => d.trim());
                    deps.forEach(dep => {
                        const depTrimmed = dep.trim();
                        const fromTaskNum = deliverableToTask[depTrimmed];
                        if (fromTaskNum) {
                            connections.push({
                                from: fromTaskNum,
                                to: task.taskNumber,
                                fromDeliverable: depTrimmed,
                                toDeliverable: task.deliverable
                            });
                        }
                    });
                }
            });
            
            return connections;
        }
        
        // Setup auto-refresh timer
        function setupAutoRefresh() {
            // Clear existing interval
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            
            const interval = smartsheetConfig.refreshInterval;
            document.getElementById('autoRefreshToggle').checked = interval > 0;
            
            if (interval > 0 && smartsheetConfig.connected) {
                autoRefreshInterval = setInterval(() => {
                    refreshFromSmartsheet();
                }, interval * 60 * 1000);
            }
        }
        
        // Toggle auto-refresh
        function toggleAutoRefresh(enabled) {
            if (enabled) {
                const interval = parseInt(document.getElementById('configRefreshInterval').value) || 5;
                smartsheetConfig.refreshInterval = interval;
            } else {
                smartsheetConfig.refreshInterval = 0;
            }
            saveSmartsheetConfigToStorage();
            setupAutoRefresh();
        }
        
        // ========================================
        // FALLBACK DATA (if Smartsheet not configured)
        // ========================================
        
        // Sample fallback data (minimal set - configure Smartsheet for full data)
        const FALLBACK_DATA = [
            {
                "governanceProcess": "PDLC",
                "category": "PMs",
                "taskNumber": "1",
                "deliverable": "Program Manager assigned",
                "description": "After Receiving approval from leadership, the HC PMO will assign a program manager.",
                "owner": "",
                "whereWorkDone": "",
                "informed": "",
                "dependencies": "",
                "links": "",
                "scenarios": {
                    "noiToGl": false, "productToGl": false, "solutionBuyCapex": false,
                    "fqToIq": false, "iqToFq": false, "skuUpdate": false,
                    "significantArchChange": false, "newRouteToMarket": false, "changeOrder": false
                },
                "depth": 1
            },
            {
                "governanceProcess": "PDLC",
                "category": "PMs",
                "taskNumber": "2",
                "deliverable": "Review Core Team Members",
                "description": "Confirm that all relevant core team members are part of the core team calls.",
                "owner": "Program Manager",
                "whereWorkDone": "",
                "informed": "",
                "dependencies": "Program Manager assigned",
                "links": "",
                "scenarios": {
                    "noiToGl": true, "productToGl": false, "solutionBuyCapex": false,
                    "fqToIq": false, "iqToFq": false, "skuUpdate": false,
                    "significantArchChange": false, "newRouteToMarket": false, "changeOrder": false
                },
                "depth": 2
            }
        ];
        
        // Initialize data (will be replaced by Smartsheet data if connected)
        async function initializeData() {
            showLoading('Initializing...');
            
            // Load saved config
            loadSmartsheetConfig();
            
            // Try to connect to Smartsheet if configured
            if (smartsheetConfig.proxyUrl && smartsheetConfig.sheetId) {
                updateSyncStatus('syncing', 'Connecting to Smartsheet...');
                const success = await refreshFromSmartsheet();
                
                if (!success) {
                    // Use fallback data
                    processDataRaw = FALLBACK_DATA;
                    dependencyConnections = generateDependencyConnections(FALLBACK_DATA);
                    updateSyncStatus('offline', 'Using local data');
                }
            } else {
                // No Smartsheet configured, use fallback
                processDataRaw = FALLBACK_DATA;
                dependencyConnections = generateDependencyConnections(FALLBACK_DATA);
                updateSyncStatus('offline', 'Configure Smartsheet to sync');
            }
            
            hideLoading();
            
            // Initialize the UI
            renderFilters();
            renderSubwayMap();
            
            // Start with filters collapsed
            document.querySelector('.filters-container').classList.add('collapsed');
            
            // Setup auto-refresh if enabled
            setupAutoRefresh();
            
            // Set scrollbar widths after render
            setTimeout(() => {
                updateScrollbarWidths();
            }, 200);
        }
        
        const scenarios = {
            noiToGl: 'NOI → GL Enablement',
            productToGl: 'Product → GL Enablement',
            solutionBuyCapex: 'Solution (BUY - CAPEX) → IQ & FQ',
            fqToIq: 'FQ → IQ',
            iqToFq: 'IQ → FQ',
            skuUpdate: 'SKU Update (Small Change)',
            significantArchChange: 'Significant Arch. Change',
            newRouteToMarket: 'New Route to Market',
            changeOrder: 'Change Order (IQ/FQ)'
        };
        
        // Track active filters
        let activeFilters = new Set(); // Scenario filters
        let activeCategoryFilters = new Set(); // Category filters
        let globalSearchQuery = ''; // Global search query
        let showConnectionsEnabled = true;
        let currentHighlightedTask = null; // Track which task's dependencies are highlighted
        let hideEmptyTracksEnabled = true; // Hide tracks with no active tasks when filtered
        let navigationHistory = []; // Track navigation path for back button
        let stationPositions = {};
        let filtersCollapsed = true; // Start collapsed
        
        // Category colors
        let categoryColors = {
            'PMs': '#01A982',
            'HPE Services': '#45B7D1',
            'CPQ Tools': '#FFA726',
            'NSI Operation': '#EC407A',
            'Pricing': '#66BB6A',
            'Finance': '#5C6BC0',
            'Integration Center': '#FF7043',
            'Partner Alliances': '#8E24AA',
            'Contract / EFR': '#F06292',
            'GL SW Engr': '#2196F3',
            'GTM (Go To Market) Readiness': '#26A69A',
            'Supply Chain - SW': '#FFB74D',
            'OCX': '#9575CD'
        };
        
        function renderFilters() {
            const filterGrid = document.getElementById('filterGrid');
            filterGrid.innerHTML = '';
            
            const counts = {};
            Object.keys(scenarios).forEach(key => {
                counts[key] = processDataRaw.filter(task => task.scenarios[key]).length;
            });
            
            Object.entries(scenarios).forEach(([key, label]) => {
                const option = document.createElement('div');
                option.className = 'filter-option';
                option.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        const checkbox = option.querySelector('input');
                        checkbox.checked = !checkbox.checked;
                        toggleFilter(key, checkbox.checked);
                    }
                };
                
                option.innerHTML = `
                    <input type="checkbox" id="filter_${key}" onchange="toggleFilter('${key}', this.checked)">
                    <label for="filter_${key}">${label}</label>
                    <span class="filter-count">${counts[key]}</span>
                `;
                
                filterGrid.appendChild(option);
            });
            
            // Render category filters
            renderCategoryFilters();
        }
        
        function renderCategoryFilters() {
            const categoryGrid = document.getElementById('categoryFilterGrid');
            categoryGrid.innerHTML = '';
            
            // Count tasks per category
            const categoryCounts = {};
            processDataRaw.forEach(task => {
                const cat = task.category || 'Other';
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });
            
            // Sort categories by count (descending)
            const sortedCategories = Object.entries(categoryCounts)
                .sort((a, b) => b[1] - a[1]);
            
            sortedCategories.forEach(([category, count]) => {
                const color = categoryColors[category] || '#425563';
                const chip = document.createElement('div');
                chip.className = 'category-chip';
                chip.style.background = color;
                chip.dataset.category = category;
                
                chip.onclick = () => toggleCategoryFilter(category);
                
                chip.innerHTML = `
                    ${category}
                    <span class="chip-count">${count}</span>
                `;
                
                categoryGrid.appendChild(chip);
            });
        }
        
        function toggleFilter(scenarioKey, isActive) {
            if (isActive) {
                activeFilters.add(scenarioKey);
            } else {
                activeFilters.delete(scenarioKey);
            }
            applyFilters();
            updateConnections();
        }
        
        function toggleCategoryFilter(category) {
            const chip = document.querySelector(`.category-chip[data-category="${category}"]`);
            
            if (activeCategoryFilters.has(category)) {
                activeCategoryFilters.delete(category);
                chip.classList.remove('inactive');
            } else {
                // If clicking to deactivate, add to inactive set
                // If no categories are inactive, this means "show only this one"
                if (activeCategoryFilters.size === 0) {
                    // First click: hide all OTHER categories
                    document.querySelectorAll('.category-chip').forEach(c => {
                        const cat = c.dataset.category;
                        if (cat !== category) {
                            activeCategoryFilters.add(cat);
                            c.classList.add('inactive');
                        }
                    });
                } else {
                    // Subsequent click: toggle this category
                    activeCategoryFilters.add(category);
                    chip.classList.add('inactive');
                }
            }
            
            applyFilters();
            updateConnections();
        }
        
        function toggleConnections(show) {
            showConnectionsEnabled = show;
            document.getElementById('connectionsLayer').style.display = show ? 'block' : 'none';
        }
        
        function applyFilters() {
            document.querySelectorAll('.station').forEach(station => {
                const taskNumber = station.dataset.task;
                const task = processDataRaw.find(t => t.taskNumber === taskNumber);
                
                if (!task) return;
                
                // Check scenario filter
                let matchesScenario = true;
                if (activeFilters.size > 0) {
                    matchesScenario = Array.from(activeFilters).some(filterKey => {
                        return task.scenarios[filterKey] === true;
                    });
                }
                
                // Check category filter
                let matchesCategory = true;
                if (activeCategoryFilters.size > 0) {
                    // Task matches if its category is NOT in the inactive set
                    matchesCategory = !activeCategoryFilters.has(task.category);
                }
                
                // Check global search
                let matchesSearch = true;
                if (globalSearchQuery) {
                    matchesSearch = taskMatchesSearch(task, globalSearchQuery);
                }
                
                // Task must match ALL filters
                if (matchesScenario && matchesCategory && matchesSearch) {
                    station.classList.remove('greyed-out');
                } else {
                    station.classList.add('greyed-out');
                }
            });
            
            // Update empty tracks visibility
            updateEmptyTracks();
            
            // Update filter badge
            updateFilterBadge();
        }
        
        // Global search functions
        function taskMatchesSearch(task, query) {
            const lowerQuery = query.toLowerCase();
            
            // Search across all text fields
            const searchableFields = [
                task.taskNumber,
                task.deliverable,
                task.description,
                task.category,
                task.owner,
                task.whereWorkDone,
                task.informed,
                task.dependencies,
                task.links
            ];
            
            return searchableFields.some(field => {
                if (!field) return false;
                return String(field).toLowerCase().includes(lowerQuery);
            });
        }
        
        function handleGlobalSearch(query) {
            globalSearchQuery = query.trim();
            
            // Show/hide clear button
            const clearBtn = document.getElementById('clearSearchBtn');
            if (clearBtn) {
                clearBtn.style.display = globalSearchQuery ? 'flex' : 'none';
            }
            
            // Apply filters (includes search)
            applyFilters();
            
            // Also filter list view if active
            if (currentView === 'list') {
                applyListFilters();
            }
            
            // Update connections
            updateConnections();
            
            // Update results count
            updateSearchResultsCount();
        }
        
        function clearGlobalSearch() {
            document.getElementById('globalSearch').value = '';
            globalSearchQuery = '';
            document.getElementById('clearSearchBtn').style.display = 'none';
            document.getElementById('searchResultsCount').textContent = '';
            
            applyFilters();
            if (currentView === 'list') {
                applyListFilters();
            }
            updateConnections();
        }
        
        function updateSearchResultsCount() {
            const countEl = document.getElementById('searchResultsCount');
            if (!globalSearchQuery) {
                countEl.textContent = '';
                countEl.classList.remove('has-results');
                return;
            }
            
            // Count visible tasks
            const visibleCount = document.querySelectorAll('.station:not(.greyed-out)').length;
            const totalCount = processDataRaw.length;
            
            countEl.textContent = `Showing ${visibleCount} of ${totalCount} tasks`;
            countEl.classList.toggle('has-results', visibleCount > 0);
        }
        
        // Collapsible filters
        function toggleFiltersPanel() {
            const container = document.querySelector('.filters-container');
            filtersCollapsed = !filtersCollapsed;
            container.classList.toggle('collapsed', filtersCollapsed);
        }
        
        function updateFilterBadge() {
            const badge = document.getElementById('filtersBadge');
            const activeCount = activeFilters.size + activeCategoryFilters.size + (globalSearchQuery ? 1 : 0);
            
            if (activeCount > 0) {
                badge.textContent = activeCount;
                badge.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
            }
        }
        
        function clearAllFilters() {
            activeFilters.clear();
            activeCategoryFilters.clear();
            
            // Clear global search
            clearGlobalSearch();
            
            // Reset scenario checkboxes
            document.querySelectorAll('.filter-option input').forEach(cb => {
                cb.checked = false;
            });
            
            // Reset category chips
            document.querySelectorAll('.category-chip').forEach(chip => {
                chip.classList.remove('inactive');
            });
            
            applyFilters();
            updateConnections();
            updateEmptyTracks();
            
            // Update list view if active
            if (currentView === 'list') {
                applyListFilters();
            }
        }
        
        function toggleEmptyTracks(enabled) {
            hideEmptyTracksEnabled = enabled;
            updateEmptyTracks();
        }
        
        function updateEmptyTracks() {
            const tracks = document.querySelectorAll('.track');
            const verticalSpacing = 140; // Must match the spacing in renderSubwayMap
            const baseOffset = 60;
            
            // Check if any filters are active
            const hasActiveFilters = activeFilters.size > 0 || activeCategoryFilters.size > 0;
            
            tracks.forEach(track => {
                const stations = track.querySelectorAll('.station');
                const rail = track.querySelector('.track-rail');
                
                // If no filters are active OR hide empty is disabled, show all and reset positions
                if (!hasActiveFilters || !hideEmptyTracksEnabled) {
                    track.classList.remove('hidden-track');
                    
                    // Reset all stations to original positions
                    stations.forEach((station, idx) => {
                        station.classList.remove('hidden-station');
                        const originalIndex = parseInt(station.dataset.index) || idx;
                        station.style.top = `${baseOffset + (originalIndex * verticalSpacing)}px`;
                    });
                    
                    // Reset rail height
                    if (rail && stations.length > 0) {
                        const maxIndex = stations.length - 1;
                        rail.style.height = `${baseOffset + (maxIndex * verticalSpacing) + 200}px`;
                    }
                    return;
                }
                
                // Check which stations are active (not greyed out)
                const activeStations = Array.from(stations).filter(station => {
                    return !station.classList.contains('greyed-out');
                });
                
                // Hide track if no active stations
                if (activeStations.length === 0) {
                    track.classList.add('hidden-track');
                    return;
                }
                
                track.classList.remove('hidden-track');
                
                // Hide greyed-out stations and reposition active ones
                let visibleIndex = 0;
                stations.forEach(station => {
                    if (station.classList.contains('greyed-out')) {
                        station.classList.add('hidden-station');
                    } else {
                        station.classList.remove('hidden-station');
                        // Reposition to condense
                        station.style.top = `${baseOffset + (visibleIndex * verticalSpacing)}px`;
                        visibleIndex++;
                    }
                });
                
                // Update rail height for visible stations only
                if (rail) {
                    const newHeight = baseOffset + ((visibleIndex - 1) * verticalSpacing) + 200;
                    rail.style.height = `${Math.max(newHeight, 200)}px`;
                }
            });
            
            // Update scrollbar widths and redraw connections after changes
            setTimeout(() => {
                updateScrollbarWidths();
                if (showConnectionsEnabled) {
                    drawConnections();
                    updateConnections();
                }
            }, 50);
        }
        
        function updateScrollbarWidths() {
            const subwayMap = document.getElementById('subwayMap');
            const scrollWidth = subwayMap.scrollWidth + 'px';
            document.getElementById('scrollTopInner').style.width = scrollWidth;
            document.getElementById('scrollBottomInner').style.width = scrollWidth;
        }
        
        function getStationPosition(taskNumber) {
            const station = document.querySelector(`[data-task="${taskNumber}"]`);
            if (!station) return null;
            
            const node = station.querySelector('.station-node');
            if (!node) return null;
            
            const mapContainer = document.getElementById('subwayMap');
            
            // Get positions relative to the subway map container
            const mapRect = mapContainer.getBoundingClientRect();
            const nodeRect = node.getBoundingClientRect();
            
            // Simple relative position - SVG is inside subway-map so no scroll adjustment needed
            return {
                x: nodeRect.left - mapRect.left + nodeRect.width / 2,
                y: nodeRect.top - mapRect.top + nodeRect.height / 2
            };
        }
        
        function drawConnections() {
            const svg = document.getElementById('connectionsLayer');
            const mapContainer = document.getElementById('subwayMap');
            
            // Set SVG size to match the actual subway map content
            const width = mapContainer.scrollWidth;
            const height = mapContainer.scrollHeight;
            
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.style.width = width + 'px';
            svg.style.height = height + 'px';
            
            // Clear existing connections
            svg.innerHTML = '';
            
            // Draw each connection
            dependencyConnections.forEach((conn, index) => {
                const fromPos = getStationPosition(conn.from);
                const toPos = getStationPosition(conn.to);
                
                if (!fromPos || !toPos) return;
                
                // Calculate control points for bezier curve
                const dx = toPos.x - fromPos.x;
                const dy = toPos.y - fromPos.y;
                
                // Create curved path
                const curve = Math.abs(dx) > 0 ? Math.abs(dx) * 0.4 : 50;
                const path = `M ${fromPos.x} ${fromPos.y} C ${fromPos.x + curve} ${fromPos.y}, ${toPos.x - curve} ${toPos.y}, ${toPos.x} ${toPos.y}`;
                
                // Create path element
                const pathElem = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElem.setAttribute('d', path);
                pathElem.setAttribute('class', 'connection-line');
                pathElem.dataset.from = conn.from;
                pathElem.dataset.to = conn.to;
                pathElem.dataset.connIndex = index;
                
                svg.appendChild(pathElem);
                
                // Draw arrow at end
                const arrowSize = 10;
                const angle = Math.atan2(dy, dx);
                const arrowPoints = [
                    [toPos.x, toPos.y],
                    [toPos.x - arrowSize * Math.cos(angle - Math.PI / 6), toPos.y - arrowSize * Math.sin(angle - Math.PI / 6)],
                    [toPos.x - arrowSize * Math.cos(angle + Math.PI / 6), toPos.y - arrowSize * Math.sin(angle + Math.PI / 6)]
                ];
                
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                arrow.setAttribute('points', arrowPoints.map(p => p.join(',')).join(' '));
                arrow.setAttribute('class', 'connection-arrow');
                arrow.dataset.from = conn.from;
                arrow.dataset.to = conn.to;
                arrow.dataset.connIndex = index;
                
                svg.appendChild(arrow);
            });
            
            stationPositions = {};
        }
        
        function updateConnections() {
            const lines = document.querySelectorAll('.connection-line, .connection-arrow');
            
            lines.forEach(elem => {
                const fromTask = elem.dataset.from;
                const toTask = elem.dataset.to;
                
                const fromStation = document.querySelector(`[data-task="${fromTask}"]`);
                const toStation = document.querySelector(`[data-task="${toTask}"]`);
                
                // Grey out connection if either station is greyed
                if (fromStation?.classList.contains('greyed-out') || toStation?.classList.contains('greyed-out')) {
                    elem.classList.add('greyed');
                } else {
                    elem.classList.remove('greyed');
                }
            });
        }
        
        function highlightConnections(taskNumber, highlight) {
            // If panel is open and we're trying to unhighlight, only allow it if we're
            // explicitly clearing the current task (not from mouse events)
            if (!highlight && document.body.classList.contains('panel-open')) {
                // Only clear if this is the currently highlighted task AND
                // we're being called from closeDetails/showAll (not mouse events)
                if (taskNumber !== currentHighlightedTask) {
                    return; // Don't clear - this is likely a stray mouse event
                }
            }
            
            // Find all connections involving this task
            const lines = document.querySelectorAll(`[data-from="${taskNumber}"], [data-to="${taskNumber}"]`);
            const stations = new Set();
            
            lines.forEach(line => {
                const fromTask = line.dataset.from;
                const toTask = line.dataset.to;
                
                // When filter is active, only highlight connections where BOTH tasks are active
                const fromActive = isTaskActive(fromTask);
                const toActive = isTaskActive(toTask);
                const shouldHighlight = activeFilters.size === 0 || (fromActive && toActive);
                
                if (highlight && shouldHighlight) {
                    line.classList.add('highlighted');
                    stations.add(fromTask);
                    stations.add(toTask);
                } else {
                    line.classList.remove('highlighted');
                }
            });
            
            // Highlight connected stations (only active ones)
            if (highlight) {
                currentHighlightedTask = taskNumber; // Track which task is highlighted
                stations.forEach(taskNum => {
                    const station = document.querySelector(`[data-task="${taskNum}"]`);
                    if (station && !station.classList.contains('greyed-out')) {
                        station.classList.add('dependency-highlighted');
                    }
                });
                // Update off-screen indicators (only for active stations)
                const activeStations = Array.from(stations).filter(t => isTaskActive(t));
                updateOffscreenIndicators(taskNumber, activeStations);
            } else {
                currentHighlightedTask = null; // Clear tracking
                document.querySelectorAll('.dependency-highlighted').forEach(s => {
                    s.classList.remove('dependency-highlighted');
                });
                // Clear off-screen indicators
                clearOffscreenIndicators();
            }
        }
        
        function updateOffscreenIndicators(activeTask, connectedTasks) {
            const container = document.getElementById('offscreenIndicators');
            const mapContainer = document.getElementById('subwayMapContainer');
            const mapRect = mapContainer.getBoundingClientRect();
            
            container.innerHTML = '';
            
            connectedTasks.forEach(taskNum => {
                if (taskNum === activeTask) return; // Skip the active task itself
                
                const station = document.querySelector(`[data-task="${taskNum}"]`);
                if (!station) return;
                
                const task = processDataRaw.find(t => t.taskNumber === taskNum);
                if (!task) return;
                
                const stationRect = station.getBoundingClientRect();
                const color = categoryColors[task.category] || '#425563';
                
                // Check if station is off-screen horizontally
                const isOffLeft = stationRect.right < mapRect.left + 50;
                const isOffRight = stationRect.left > mapRect.right - 100;
                
                if (isOffLeft || isOffRight) {
                    const indicator = document.createElement('div');
                    indicator.className = `offscreen-indicator ${isOffLeft ? 'left' : 'right'}`;
                    indicator.style.setProperty('--indicator-color', color);
                    
                    // Position vertically aligned with the station
                    const topPos = Math.max(100, Math.min(stationRect.top, window.innerHeight - 80));
                    indicator.style.top = `${topPos}px`;
                    
                    indicator.innerHTML = `
                        <div class="indicator-node">${taskNum.toString().split('.')[0]}</div>
                        <div class="indicator-label">${task.deliverable.substring(0, 25)}${task.deliverable.length > 25 ? '...' : ''}</div>
                    `;
                    
                    // Click to scroll to that task
                    indicator.onclick = () => {
                        const stationLeft = station.offsetLeft;
                        const trackParent = station.closest('.track');
                        const trackLeft = trackParent ? trackParent.offsetLeft : 0;
                        mapContainer.scrollLeft = trackLeft - mapRect.width / 2 + 100;
                    };
                    
                    container.appendChild(indicator);
                }
            });
        }
        
        function clearOffscreenIndicators() {
            const container = document.getElementById('offscreenIndicators');
            container.innerHTML = '';
        }
        
        function renderSubwayMap() {
            const mapContainer = document.getElementById('subwayMap');
            mapContainer.innerHTML = '';
            
            // Re-create the SVG connections layer inside the map
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'connections-layer');
            svg.setAttribute('id', 'connectionsLayer');
            mapContainer.appendChild(svg);
            
            const grouped = {};
            processDataRaw.forEach(item => {
                const cat = item.category || 'Other';
                if (!grouped[cat]) {
                    grouped[cat] = [];
                }
                grouped[cat].push(item);
            });
            
            const sortedCategories = Object.keys(grouped).sort((a, b) => {
                return grouped[b].length - grouped[a].length;
            });
            
            sortedCategories.forEach(category => {
                const track = document.createElement('div');
                track.className = 'track';
                track.dataset.category = category;
                
                const color = categoryColors[category] || '#425563';
                
                const trackHeader = document.createElement('div');
                trackHeader.className = 'track-header';
                trackHeader.innerHTML = `
                    <div class="track-label" style="background: ${color};">
                        ${category}
                    </div>
                `;
                
                const trackLine = document.createElement('div');
                trackLine.className = 'track-line';
                
                const rail = document.createElement('div');
                rail.className = 'track-rail';
                rail.style.background = color;
                
                // Sort tasks by task number within this category
                const sortedTasks = grouped[category].sort((a, b) => {
                    return parseFloat(a.taskNumber) - parseFloat(b.taskNumber);
                });
                
                trackLine.appendChild(rail);
                
                let lastTaskPosition = 0;
                
                sortedTasks.forEach((item, index) => {
                    const station = document.createElement('div');
                    station.className = 'station';
                    station.dataset.task = item.taskNumber;
                    station.dataset.index = index; // Store original index for repositioning
                    
                    // Position SEQUENTIALLY by index (first task at top, second below, etc.)
                    const verticalSpacing = 140; // pixels between tasks
                    const baseOffset = 60; // initial offset from top
                    
                    // Simple sequential position
                    const topPosition = baseOffset + (index * verticalSpacing);
                    
                    // Track the MAXIMUM task position for this track (for rail height)
                    lastTaskPosition = Math.max(lastTaskPosition, topPosition);
                    
                    station.style.position = 'absolute';
                    station.style.top = `${topPosition}px`;
                    station.style.left = '50%';
                    station.style.transform = 'translateX(-50%)';
                    station.style.setProperty('--track-color', color);
                    
                    station.onmouseenter = () => {
                        // Only highlight on hover if panel is NOT open and task is not greyed out
                        if (!station.classList.contains('greyed-out') && 
                            showConnectionsEnabled && 
                            !document.body.classList.contains('panel-open')) {
                            highlightConnections(item.taskNumber, true);
                        }
                    };
                    
                    station.onmouseleave = () => {
                        // Only unhighlight on mouse leave if panel is NOT open
                        // When panel is open, highlights persist until user clicks another action or closes panel
                        if (!document.body.classList.contains('panel-open')) {
                            highlightConnections(item.taskNumber, false);
                        }
                    };
                    
                    station.onclick = (e) => {
                        e.stopPropagation(); // Prevent any bubbling issues
                        if (!station.classList.contains('greyed-out')) {
                            showDetails(item.taskNumber);
                        }
                    };
                    
                    station.innerHTML = `
                        <div class="station-node">
                            ${item.taskNumber.split('.')[0]}
                        </div>
                        <div class="station-label">
                            ${item.deliverable.substring(0, 60)}${item.deliverable.length > 60 ? '...' : ''}
                        </div>
                    `;
                    
                    trackLine.appendChild(station);
                });
                
                // Set rail height and track-line height to end well below last task
                const trackHeight = lastTaskPosition + 350;
                rail.style.height = `${trackHeight}px`;
                rail.style.bottom = 'auto';
                trackLine.style.minHeight = `${trackHeight}px`;
                
                track.appendChild(trackHeader);
                track.appendChild(trackLine);
                mapContainer.appendChild(track);
            });
            
            // Draw connections after DOM is ready
            setTimeout(() => {
                drawConnections();
                checkScrollable();
            }, 300);
        }
        
        // Check if a task is active (not greyed out) based on current filters
        // Check if a task is active (not greyed out) based on current filters
        function isTaskActive(taskNumber) {
            if (activeFilters.size === 0 && activeCategoryFilters.size === 0) return true; // No filter = all active
            const station = document.querySelector(`[data-task="${taskNumber}"]`);
            return station && !station.classList.contains('greyed-out');
        }
        
        // Navigate to a task, optionally adding current task to history
        function navigateToTask(taskNumber, addToHistory = true) {
            const panel = document.getElementById('detailPanel');
            const currentTask = panel.dataset.currentTask;
            
            // Add current task to history before navigating (if panel is open)
            if (addToHistory && currentTask && panel.classList.contains('open')) {
                navigationHistory.push(currentTask);
            }
            
            showDetails(taskNumber);
        }
        
        // Navigate back to previous task
        function navigateBack() {
            if (navigationHistory.length === 0) return;
            
            const previousTask = navigationHistory.pop();
            showDetails(previousTask); // Don't add to history when going back
        }
        
        function showDetails(taskNumber) {
            const task = processDataRaw.find(t => t.taskNumber === taskNumber);
            if (!task) return;
            
            const panel = document.getElementById('detailPanel');
            const overlay = document.getElementById('overlay');
            const content = document.getElementById('detailContent');
            const backButtonContainer = document.getElementById('backButtonContainer');
            
            // Store the currently open task for later reference
            panel.dataset.currentTask = taskNumber;
            
            // Update back button visibility
            if (navigationHistory.length > 0) {
                const prevTask = navigationHistory[navigationHistory.length - 1];
                const prevTaskData = processDataRaw.find(t => t.taskNumber === prevTask);
                const prevLabel = prevTaskData ? prevTaskData.deliverable.substring(0, 25) : `Task #${prevTask}`;
                backButtonContainer.innerHTML = `
                    <button class="back-btn" onclick="navigateBack()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 12H5M12 19l-7-7 7-7"/>
                        </svg>
                        Back to ${prevLabel}${prevTaskData && prevTaskData.deliverable.length > 25 ? '...' : ''}
                    </button>
                `;
            } else {
                backButtonContainer.innerHTML = '';
            }
            
            document.getElementById('detailTitle').textContent = task.deliverable;
            document.getElementById('detailTaskNumber').textContent = `Task #${task.taskNumber}`;
            
            const deps = task.dependencies.split('\n').filter(d => d.trim() !== '');
            const links = task.links.split('\n').filter(l => l.trim() !== '');
            
            // Get connections for this task - filter by active status when filters applied
            const incomingDeps = dependencyConnections.filter(c => c.to === task.taskNumber);
            const outgoingDeps = dependencyConnections.filter(c => c.from === task.taskNumber);
            
            // Filter to only active dependencies when a filter is applied
            const activeIncomingDeps = activeFilters.size > 0 
                ? incomingDeps.filter(dep => isTaskActive(dep.from))
                : incomingDeps;
            const activeOutgoingDeps = activeFilters.size > 0
                ? outgoingDeps.filter(dep => isTaskActive(dep.to))
                : outgoingDeps;
            
            // Get applicable scenarios
            const applicableScenarios = Object.entries(scenarios)
                .filter(([key, label]) => task.scenarios[key])
                .map(([key, label]) => label);
            
            content.innerHTML = `
                <div class="detail-section">
                    <h3>Category</h3>
                    <p>
                        <span class="tag tag-category">${task.category}</span>
                        ${task.governanceProcess ? `<span class="tag tag-governance">${task.governanceProcess}</span>` : ''}
                    </p>
                </div>
                
                ${applicableScenarios.length > 0 ? `
                <div class="detail-section">
                    <h3>Applicable Scenarios</h3>
                    <div class="scenario-badges">
                        ${applicableScenarios.map(s => `<span class="scenario-badge">${s}</span>`).join('')}
                    </div>
                </div>
                ` : ''}
                
                <div class="detail-section">
                    <h3>Description</h3>
                    <div>${renderDescription(task.description) || 'No description available'}</div>
                </div>
                
                <div class="detail-section">
                    <h3>Owner</h3>
                    <p>${task.owner || 'Not specified'}</p>
                </div>
                
                <div class="detail-section">
                    <h3>Where Work Gets Done</h3>
                    <p>${task.whereWorkDone || 'Not specified'}</p>
                </div>
                
                ${task.informed ? `
                <div class="detail-section">
                    <h3>Informed Parties</h3>
                    <p>${task.informed}</p>
                </div>
                ` : ''}
                
                ${activeIncomingDeps.length > 0 ? `
                <div class="detail-section">
                    <h3>Dependencies (${activeIncomingDeps.length}${activeFilters.size > 0 && activeIncomingDeps.length < incomingDeps.length ? ' of ' + incomingDeps.length : ''})</h3>
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                        This task depends on:
                    </p>
                    ${activeIncomingDeps.map(dep => `
                        <div class="dependency-item linked" onclick="navigateToTask('${dep.from}')">
                            ${dep.fromDeliverable}
                            <span class="dep-badge">Task ${dep.from}</span>
                        </div>
                    `).join('')}
                </div>
                ` : deps.length > 0 && activeFilters.size === 0 ? `
                <div class="detail-section">
                    <h3>Dependencies</h3>
                    ${deps.map(dep => `<div class="dependency-item">${dep}</div>`).join('')}
                </div>
                ` : ''}
                
                ${activeOutgoingDeps.length > 0 ? `
                <div class="detail-section">
                    <h3>Required By (${activeOutgoingDeps.length}${activeFilters.size > 0 && activeOutgoingDeps.length < outgoingDeps.length ? ' of ' + outgoingDeps.length : ''})</h3>
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                        These tasks depend on this one:
                    </p>
                    ${activeOutgoingDeps.map(dep => `
                        <div class="dependency-item linked" onclick="navigateToTask('${dep.to}')">
                            ${dep.toDeliverable}
                            <span class="dep-badge">Task ${dep.to}</span>
                        </div>
                    `).join('')}
                </div>
                ` : ''}
                
                ${links.length > 0 ? `
                <div class="detail-section">
                    <h3>Useful Links & Documentation</h3>
                    <ul>
                        ${links.map(link => {
                            if (link.includes('http://') || link.includes('https://')) {
                                return `<li><a href="${link}" target="_blank" style="color: var(--hpe-green); text-decoration: none;">${link}</a></li>`;
                            }
                            return `<li>${link}</li>`;
                        }).join('')}
                    </ul>
                </div>
                ` : ''}
            `;
            
            panel.classList.add('open');
            overlay.classList.add('active');
            document.body.classList.add('panel-open');
            
            // Clear ALL previous highlights first
            document.querySelectorAll('.station').forEach(s => {
                s.classList.remove('active');
                s.classList.remove('dependency-highlighted');
            });
            document.querySelectorAll('.track').forEach(t => t.classList.remove('active-track'));
            document.querySelectorAll('.connection-line, .connection-arrow').forEach(line => {
                line.classList.remove('highlighted');
            });
            clearOffscreenIndicators();
            
            // Mark the selected station and its track as active
            const activeStation = document.querySelector(`[data-task="${taskNumber}"]`);
            if (activeStation) {
                activeStation.classList.add('active');
                // Find the parent track and mark it active
                const parentTrack = activeStation.closest('.track');
                if (parentTrack) {
                    parentTrack.classList.add('active-track');
                }
                
                // Auto-scroll to center the selected task (accounting for panel width)
                const mapContainer = document.getElementById('subwayMapContainer');
                const panelWidth = 650; // Width of the detail panel
                const viewportWidth = window.innerWidth - panelWidth;
                const trackLeft = parentTrack ? parentTrack.offsetLeft : activeStation.offsetLeft;
                const trackWidth = parentTrack ? parentTrack.offsetWidth : 200;
                
                // Calculate scroll position to center the track in the visible area (left of panel)
                const targetScrollLeft = trackLeft - (viewportWidth / 2) + (trackWidth / 2);
                
                // Smooth scroll to position
                mapContainer.scrollTo({
                    left: Math.max(0, targetScrollLeft),
                    behavior: 'smooth'
                });
            }
            
            // Highlight dependency connections for the selected task (filtered by active)
            highlightConnections(taskNumber, true);
        }
        
        function closeDetails() {
            const panel = document.getElementById('detailPanel');
            const currentTask = panel.dataset.currentTask;
            
            panel.classList.remove('open');
            document.getElementById('overlay').classList.remove('active');
            document.body.classList.remove('panel-open');
            document.querySelectorAll('.station').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.track').forEach(t => t.classList.remove('active-track'));
            
            // Remove connection highlighting
            if (currentTask) {
                highlightConnections(currentTask, false);
            }
            panel.dataset.currentTask = '';
            
            // Clear navigation history
            navigationHistory = [];
            document.getElementById('backButtonContainer').innerHTML = '';
        }
        
        function showAll() {
            // Close the detail panel
            closeDetails();
            
            // Clear the tracking variable
            currentHighlightedTask = null;
            
            // Clear all highlighting
            document.querySelectorAll('.station').forEach(s => {
                s.classList.remove('active');
                s.classList.remove('dependency-highlighted');
            });
            document.querySelectorAll('.track').forEach(t => t.classList.remove('active-track'));
            document.querySelectorAll('.connection-line, .connection-arrow').forEach(line => {
                line.classList.remove('highlighted');
            });
            
            // Clear off-screen indicators
            clearOffscreenIndicators();
            
            // Reset body state
            document.body.classList.remove('panel-open');
            
            // Redraw connections to show all (if enabled)
            if (showConnectionsEnabled) {
                drawConnections();
                updateConnections();
            }
        }
        
        function checkScrollable() {
            const container = document.querySelector('.container');
            const hint = document.getElementById('scrollHint');
            
            if (container.scrollWidth > container.clientWidth) {
                hint.style.display = 'block';
                
                let hintTimer = setTimeout(() => {
                    hint.style.display = 'none';
                }, 5000);
                
                container.addEventListener('scroll', () => {
                    clearTimeout(hintTimer);
                    hint.style.display = 'none';
                }, { once: true });
            }
        }
        
        // Event listeners
        document.getElementById('closeBtn').addEventListener('click', closeDetails);
        document.getElementById('overlay').addEventListener('click', closeDetails);
        document.getElementById('clearFilters').addEventListener('click', clearAllFilters);
        
        // Sync all three scrollbars (top, main, bottom)
        const scrollTop = document.getElementById('scrollTop');
        const scrollBottom = document.getElementById('scrollBottom');
        const mapContainer = document.getElementById('subwayMapContainer');
        
        let isSyncing = false;
        
        // Function to refresh off-screen indicators when scrolling
        function refreshIndicatorsOnScroll() {
            if (document.body.classList.contains('panel-open')) {
                const panel = document.getElementById('detailPanel');
                const currentTask = panel.dataset.currentTask;
                if (currentTask) {
                    const connectedStations = [];
                    document.querySelectorAll('.dependency-highlighted').forEach(s => {
                        connectedStations.push(s.dataset.task);
                    });
                    const activeStation = document.querySelector('.station.active');
                    if (activeStation) {
                        connectedStations.push(activeStation.dataset.task);
                    }
                    updateOffscreenIndicators(currentTask, connectedStations);
                }
            }
        }
        
        mapContainer.addEventListener('scroll', () => {
            if (isSyncing) return;
            isSyncing = true;
            scrollTop.scrollLeft = mapContainer.scrollLeft;
            scrollBottom.scrollLeft = mapContainer.scrollLeft;
            isSyncing = false;
            refreshIndicatorsOnScroll();
        });
        
        scrollTop.addEventListener('scroll', () => {
            if (isSyncing) return;
            isSyncing = true;
            mapContainer.scrollLeft = scrollTop.scrollLeft;
            scrollBottom.scrollLeft = scrollTop.scrollLeft;
            isSyncing = false;
            refreshIndicatorsOnScroll();
        });
        
        scrollBottom.addEventListener('scroll', () => {
            if (isSyncing) return;
            isSyncing = true;
            mapContainer.scrollLeft = scrollBottom.scrollLeft;
            scrollTop.scrollLeft = scrollBottom.scrollLeft;
            isSyncing = false;
            refreshIndicatorsOnScroll();
        });
        
        // Redraw on window resize
        window.addEventListener('resize', () => {
            if (showConnectionsEnabled) {
                drawConnections();
            }
            updateScrollbarWidths();
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDetails();
                closeEditModal();
                closePinModal();
            }
        });
        
        // =====================
        // VIEW SWITCHING
        // =====================
        let currentView = 'map';
        
        function switchView(view) {
            currentView = view;
            
            // Update buttons
            document.getElementById('mapViewBtn').classList.toggle('active', view === 'map');
            document.getElementById('listViewBtn').classList.toggle('active', view === 'list');
            
            // Show/hide containers
            document.getElementById('mapViewContainer').style.display = view === 'map' ? 'block' : 'none';
            document.getElementById('listViewContainer').style.display = view === 'list' ? 'block' : 'none';
            
            // Show/hide map-specific controls
            document.getElementById('connectionsToggle').style.display = view === 'map' ? 'flex' : 'none';
            document.getElementById('showAllBtn').style.display = view === 'map' && document.body.classList.contains('panel-open') ? 'block' : 'none';
            
            // Render list if switching to list view
            if (view === 'list') {
                renderListView();
            }
        }
        
        // =====================
        // LIST VIEW RENDERING
        // =====================
        function renderListView() {
            const tbody = document.getElementById('taskTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Sort tasks by task number
            const sortedTasks = [...processDataRaw].sort((a, b) => {
                const numA = parseFloat(a.taskNumber) || 0;
                const numB = parseFloat(b.taskNumber) || 0;
                return numA - numB;
            });
            
            sortedTasks.forEach(task => {
                try {
                    const row = document.createElement('tr');
                    row.dataset.taskNumber = task.taskNumber;
                    
                    // Check if filtered out
                    const isFilteredOut = !isTaskActiveForList(task);
                    if (isFilteredOut) {
                        row.classList.add('filtered-out');
                    }
                    
                    const color = categoryColors[task.category] || '#425563';
                    
                    // Get dependencies as links with task number AND deliverable name
                    const deps = dependencyConnections.filter(c => c.to === task.taskNumber);
                    const depsHtml = deps.length > 0 
                        ? deps.map(d => {
                            const shortName = (d.fromDeliverable || '').length > 25 
                                ? d.fromDeliverable.substring(0, 25) + '...' 
                                : (d.fromDeliverable || '');
                            const escapedTitle = escapeHtmlAttr(d.fromDeliverable || '');
                            // Get the category color for this dependency
                            const depTask = processDataRaw.find(t => t.taskNumber === d.from);
                            const depColor = depTask ? (categoryColors[depTask.category] || '#425563') : '#425563';
                            // Convert hex to rgba for background
                            const r = parseInt(depColor.slice(1,3), 16);
                            const g = parseInt(depColor.slice(3,5), 16);
                            const b = parseInt(depColor.slice(5,7), 16);
                            return `<span class="dep-link" onclick="scrollToTask('${d.from}')" title="${escapedTitle}" style="border-left-color: ${depColor}; background: rgba(${r},${g},${b},0.1);">
                                <strong style="color: ${depColor};">#${d.from}</strong> ${escapeHtml(shortName)}
                            </span>`;
                        }).join('')
                        : '<span style="color: #999;">None</span>';
                    
                    // Render description with HTML support
                    const descHtml = renderDescription(task.description || '');
                    
                    // Escape deliverable for display
                    const deliverableHtml = escapeHtml(task.deliverable || '');
                    const categoryHtml = escapeHtml(task.category || '');
                    const ownerHtml = escapeHtml(task.owner || '-');
                    
                    row.innerHTML = `
                        <td class="task-num">#${task.taskNumber}</td>
                        <td><span class="category-badge" style="background: ${color}">${categoryHtml}</span></td>
                        <td class="deliverable-cell">${deliverableHtml}</td>
                        <td class="desc-cell">${descHtml}</td>
                        <td class="owner-cell">${ownerHtml}</td>
                        <td class="deps-cell">${depsHtml}</td>
                        <td><button class="action-btn edit-btn" onclick="checkEditAuth('${task.taskNumber}')">✏️ Edit</button></td>
                    `;
                    
                    tbody.appendChild(row);
                } catch (err) {
                    console.error('Error rendering task row:', task.taskNumber, err);
                }
            });
        }
        
        // Helper to escape HTML for display
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper to escape HTML for attribute values
        function escapeHtmlAttr(text) {
            if (!text) return '';
            return text.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }
        
        function isTaskActiveForList(task) {
            // Check scenario filter
            let matchesScenario = true;
            if (activeFilters.size > 0) {
                matchesScenario = Array.from(activeFilters).some(filterKey => {
                    return task.scenarios[filterKey] === true;
                });
            }
            
            // Check category filter
            let matchesCategory = true;
            if (activeCategoryFilters.size > 0) {
                matchesCategory = !activeCategoryFilters.has(task.category);
            }
            
            // Check global search
            let matchesSearch = true;
            if (globalSearchQuery) {
                matchesSearch = taskMatchesSearch(task, globalSearchQuery);
            }
            
            return matchesScenario && matchesCategory && matchesSearch;
        }
        
        function renderDescription(desc) {
            if (!desc) return '-';
            
            try {
                // Trim and check for content
                desc = String(desc).trim();
                if (!desc) return '-';
                
                // Check if description already contains HTML tags (not escaped)
                if (/<[a-z][\s\S]*>/i.test(desc)) {
                    // Already has HTML, sanitize and return
                    return sanitizeHtml(desc);
                }
                
                // Check for escaped HTML (entities like &lt;)
                if (/&lt;[a-z]/i.test(desc)) {
                    // Decode entities first, then sanitize
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = desc;
                    const decoded = textarea.value;
                    return sanitizeHtml(decoded);
                }
                
                // Convert plain text to HTML
                let html = desc
                    .replace(/\n\* /g, '</li><li>')  // Convert bullet points
                    .replace(/^\* /g, '<li>')         // First bullet
                    .replace(/\n/g, '<br>');          // Regular newlines
                
                // Wrap bullet lists in <ul>
                if (html.includes('<li>')) {
                    const items = html.replace(/<li>/g, '').split('</li>').filter(s => s.trim());
                    html = '<ul>' + items.map(s => `<li>${s.trim()}</li>`).join('') + '</ul>';
                }
                
                return html;
            } catch (err) {
                console.error('Error rendering description:', err);
                // Return plain text as-is, let browser handle it
                return desc || '-';
            }
        }
        
        function sanitizeHtml(html) {
            if (!html) return '';
            
            try {
                // Allow only safe tags
                const allowedTags = ['b', 'i', 'u', 'strong', 'em', 'br', 'p', 'ul', 'ol', 'li', 'a', 'span', 'div'];
                const doc = new DOMParser().parseFromString(html, 'text/html');
                
                function cleanNode(node) {
                    if (!node) return;
                    if (node.nodeType === 3) return; // Text node
                    if (node.nodeType === 1) { // Element node
                        const tagName = node.tagName.toLowerCase();
                        if (!allowedTags.includes(tagName)) {
                            // Replace with text content
                            const text = document.createTextNode(node.textContent);
                            if (node.parentNode) {
                                node.parentNode.replaceChild(text, node);
                            }
                            return;
                        }
                        // Clean attributes except href and style for links
                        Array.from(node.attributes || []).forEach(attr => {
                            if (attr.name !== 'href' && attr.name !== 'style') {
                                node.removeAttribute(attr.name);
                            }
                        });
                        // Recursively clean children
                        Array.from(node.childNodes || []).forEach(cleanNode);
                    }
                }
                
                cleanNode(doc.body);
                return doc.body.innerHTML;
            } catch (err) {
                console.error('Error sanitizing HTML:', err);
                // Return the HTML as-is instead of escaping it
                // The browser's innerHTML will handle any dangerous content
                return html;
            }
        }
        
        function scrollToTask(taskNumber) {
            if (currentView === 'list') {
                const row = document.querySelector(`tr[data-task-number="${taskNumber}"]`);
                if (row) {
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    row.style.background = '#E8F5F1';
                    setTimeout(() => {
                        row.style.background = '';
                    }, 2000);
                }
            } else {
                // Switch to map and show task
                switchView('map');
                setTimeout(() => showDetails(taskNumber), 100);
            }
        }
        
        function applyListFilters() {
            if (currentView !== 'list') return;
            
            document.querySelectorAll('#taskTableBody tr').forEach(row => {
                const taskNumber = row.dataset.taskNumber;
                const task = processDataRaw.find(t => t.taskNumber === taskNumber);
                if (task && isTaskActiveForList(task)) {
                    row.classList.remove('filtered-out');
                } else {
                    row.classList.add('filtered-out');
                }
            });
        }
        
        // =====================
        // EDIT MODAL
        // =====================
        let editingTaskNumber = null;
        let selectedDependencies = [];
        let isEditAuthenticated = false;
        const EDIT_PIN = '19731972';
        
        // =====================
        // PIN AUTHENTICATION
        // =====================
        function checkEditAuth(taskNumber) {
            if (isEditAuthenticated) {
                openEditModal(taskNumber);
                return;
            }
            
            // Show PIN modal
            document.getElementById('pinTaskNumber').value = taskNumber;
            document.getElementById('pinInput').value = '';
            document.getElementById('pinError').style.display = 'none';
            document.getElementById('pinModal').classList.add('active');
            document.getElementById('pinInput').focus();
        }
        
        function verifyPin() {
            const enteredPin = document.getElementById('pinInput').value;
            const taskNumber = document.getElementById('pinTaskNumber').value;
            
            if (enteredPin === EDIT_PIN) {
                isEditAuthenticated = true;
                closePinModal();
                openEditModal(taskNumber);
            } else {
                document.getElementById('pinError').style.display = 'block';
                document.getElementById('pinInput').value = '';
                document.getElementById('pinInput').focus();
            }
        }
        
        function closePinModal() {
            document.getElementById('pinModal').classList.remove('active');
            document.getElementById('pinInput').value = '';
        }
        
        // Handle Enter key in PIN input
        document.addEventListener('DOMContentLoaded', function() {
            const pinInput = document.getElementById('pinInput');
            if (pinInput) {
                pinInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        verifyPin();
                    }
                });
            }
        });
        
        // =====================
        // RICH TEXT EDITOR
        // =====================
        function formatText(command) {
            document.execCommand(command, false, null);
            document.getElementById('editDescriptionEditor').focus();
        }
        
        function insertLink() {
            const url = prompt('Enter URL:', 'https://');
            if (url) {
                document.execCommand('createLink', false, url);
            }
            document.getElementById('editDescriptionEditor').focus();
        }
        
        function clearFormatting() {
            document.execCommand('removeFormat', false, null);
            document.getElementById('editDescriptionEditor').focus();
        }
        
        // Keyboard shortcuts for formatting
        document.addEventListener('keydown', function(e) {
            const editor = document.getElementById('editDescriptionEditor');
            if (!editor || document.activeElement !== editor) return;
            
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'b':
                        e.preventDefault();
                        formatText('bold');
                        break;
                    case 'i':
                        e.preventDefault();
                        formatText('italic');
                        break;
                    case 'u':
                        e.preventDefault();
                        formatText('underline');
                        break;
                }
            }
        });
        
        // =====================
        // DEPENDENCY PICKER
        // =====================
        function showDependencyDropdown() {
            populateDependencyDropdown('');
            document.getElementById('dependencyDropdown').classList.add('active');
        }
        
        function hideDependencyDropdown() {
            setTimeout(() => {
                document.getElementById('dependencyDropdown').classList.remove('active');
            }, 200);
        }
        
        function searchDependencies(query) {
            populateDependencyDropdown(query);
            document.getElementById('dependencyDropdown').classList.add('active');
        }
        
        function populateDependencyDropdown(query) {
            const dropdown = document.getElementById('dependencyDropdown');
            dropdown.innerHTML = '';
            
            const lowerQuery = query.toLowerCase().trim();
            
            // Filter tasks - exclude the currently editing task
            let filteredTasks = processDataRaw.filter(task => {
                if (task.taskNumber === editingTaskNumber) return false;
                
                if (!lowerQuery) return true;
                
                const matchesNumber = task.taskNumber.toLowerCase().includes(lowerQuery);
                const matchesDeliverable = task.deliverable.toLowerCase().includes(lowerQuery);
                const matchesCategory = task.category.toLowerCase().includes(lowerQuery);
                
                return matchesNumber || matchesDeliverable || matchesCategory;
            });
            
            // Sort by task number
            filteredTasks.sort((a, b) => {
                const numA = parseFloat(a.taskNumber) || 0;
                const numB = parseFloat(b.taskNumber) || 0;
                return numA - numB;
            });
            
            // Limit results
            filteredTasks = filteredTasks.slice(0, 15);
            
            if (filteredTasks.length === 0) {
                dropdown.innerHTML = '<div class="dependency-option" style="color: #999; cursor: default;">No matching tasks found</div>';
                return;
            }
            
            filteredTasks.forEach(task => {
                const isSelected = selectedDependencies.some(d => d.taskNumber === task.taskNumber);
                const taskColor = categoryColors[task.category] || '#425563';
                
                const option = document.createElement('div');
                option.className = 'dependency-option' + (isSelected ? ' already-selected' : '');
                option.style.borderLeft = `3px solid ${taskColor}`;
                option.innerHTML = `
                    <span class="task-num" style="color: ${taskColor};">#${task.taskNumber}</span>
                    <span class="deliverable-name">${task.deliverable}</span>
                    <span class="category-tag" style="background: ${taskColor}; color: white;">${task.category}</span>
                `;
                
                if (!isSelected) {
                    option.onclick = () => addDependency(task.taskNumber, task.deliverable);
                }
                
                dropdown.appendChild(option);
            });
        }
        
        function addDependency(taskNumber, deliverable) {
            // Check if already added
            if (selectedDependencies.some(d => d.taskNumber === taskNumber)) {
                return;
            }
            
            selectedDependencies.push({ taskNumber, deliverable });
            renderSelectedDependencies();
            
            // Update dropdown to show as selected
            document.getElementById('dependencySearch').value = '';
            populateDependencyDropdown('');
        }
        
        function removeDependency(taskNumber) {
            selectedDependencies = selectedDependencies.filter(d => d.taskNumber !== taskNumber);
            renderSelectedDependencies();
            populateDependencyDropdown(document.getElementById('dependencySearch').value);
        }
        
        function renderSelectedDependencies() {
            const container = document.getElementById('selectedDependencies');
            
            if (selectedDependencies.length === 0) {
                container.innerHTML = '<span class="no-deps-message">No dependencies selected. Search above to add.</span>';
                return;
            }
            
            // Update to show category colors
            container.innerHTML = selectedDependencies.map(dep => {
                const depTask = processDataRaw.find(t => t.taskNumber === dep.taskNumber);
                const depColor = depTask ? (categoryColors[depTask.category] || '#425563') : '#425563';
                // Convert hex to rgba for background
                const r = parseInt(depColor.slice(1,3), 16);
                const g = parseInt(depColor.slice(3,5), 16);
                const b = parseInt(depColor.slice(5,7), 16);
                return `
                <div class="selected-dep-tag" style="border-color: ${depColor}; background: rgba(${r},${g},${b},0.08);">
                    <span class="dep-num" style="color: ${depColor};">#${dep.taskNumber}</span>
                    <span class="dep-name" title="${escapeHtmlAttr(dep.deliverable)}">${escapeHtml(dep.deliverable)}</span>
                    <button type="button" class="remove-dep" onclick="removeDependency('${dep.taskNumber}')" title="Remove">×</button>
                </div>
            `}).join('');
        }
        
        // =====================
        // ROLE PICKER (Where Work Gets Done)
        // =====================
        let selectedRoles = [];
        let allRoles = [];
        
        function buildRoleOptions() {
            const roles = new Set();
            
            processDataRaw.forEach(task => {
                if (task.whereWorkDone && task.whereWorkDone.trim()) {
                    // Split by newlines
                    task.whereWorkDone.split(/\n/).forEach(r => {
                        const trimmed = r.trim();
                        if (trimmed) roles.add(trimmed);
                    });
                }
            });
            
            allRoles = [...roles].sort();
        }
        
        function showRoleDropdown() {
            populateRoleDropdown('');
            document.getElementById('roleDropdown').classList.add('active');
        }
        
        function searchRoles(query) {
            populateRoleDropdown(query);
            document.getElementById('roleDropdown').classList.add('active');
        }
        
        function populateRoleDropdown(query) {
            const dropdown = document.getElementById('roleDropdown');
            dropdown.innerHTML = '';
            
            const lowerQuery = query.toLowerCase().trim();
            
            // Filter roles
            let filtered = allRoles.filter(role => 
                role.toLowerCase().includes(lowerQuery)
            );
            
            // Limit to 10
            filtered = filtered.slice(0, 10);
            
            filtered.forEach(role => {
                const isSelected = selectedRoles.includes(role);
                
                const option = document.createElement('div');
                option.className = 'role-option' + (isSelected ? ' already-selected' : '');
                option.textContent = role;
                
                if (!isSelected) {
                    option.onclick = () => addRole(role);
                }
                
                dropdown.appendChild(option);
            });
            
            // Add "Add new" option if query doesn't match any existing
            if (lowerQuery && !allRoles.some(r => r.toLowerCase() === lowerQuery)) {
                const addNew = document.createElement('div');
                addNew.className = 'role-option add-new';
                addNew.textContent = `+ Add "${query}"`;
                addNew.onclick = () => addRole(query);
                dropdown.appendChild(addNew);
            }
            
            if (dropdown.children.length === 0) {
                const noMatch = document.createElement('div');
                noMatch.className = 'role-option';
                noMatch.style.color = '#999';
                noMatch.textContent = 'No matching roles found';
                dropdown.appendChild(noMatch);
            }
        }
        
        function addRole(role) {
            if (selectedRoles.includes(role)) return;
            
            selectedRoles.push(role);
            renderSelectedRoles();
            
            // Clear and update dropdown
            document.getElementById('roleSearch').value = '';
            populateRoleDropdown('');
        }
        
        function removeRole(role) {
            selectedRoles = selectedRoles.filter(r => r !== role);
            renderSelectedRoles();
            populateRoleDropdown(document.getElementById('roleSearch').value);
        }
        
        function renderSelectedRoles() {
            const container = document.getElementById('selectedRoles');
            
            if (selectedRoles.length === 0) {
                container.innerHTML = '<span class="no-roles-message">No roles selected. Search above to add.</span>';
                return;
            }
            
            container.innerHTML = selectedRoles.map((role, idx) => `
                <div class="selected-role-tag">
                    <span class="role-name">${escapeHtml(role)}</span>
                    <button type="button" class="remove-role" data-role-index="${idx}" title="Remove">×</button>
                </div>
            `).join('');
            
            // Add click handlers
            container.querySelectorAll('.remove-role').forEach(btn => {
                btn.onclick = () => {
                    const idx = parseInt(btn.dataset.roleIndex);
                    removeRoleByIndex(idx);
                };
            });
        }
        
        function removeRoleByIndex(idx) {
            selectedRoles.splice(idx, 1);
            renderSelectedRoles();
            populateRoleDropdown(document.getElementById('roleSearch').value);
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('dependencyDropdown');
            const searchInput = document.getElementById('dependencySearch');
            
            if (dropdown && !dropdown.contains(e.target) && e.target !== searchInput) {
                dropdown.classList.remove('active');
            }
            
            // Close role dropdown
            const roleDropdown = document.getElementById('roleDropdown');
            const roleSearch = document.getElementById('roleSearch');
            if (roleDropdown && !roleDropdown.contains(e.target) && e.target !== roleSearch) {
                roleDropdown.classList.remove('active');
            }
            
            // Close autocomplete dropdowns
            document.querySelectorAll('.autocomplete-dropdown').forEach(dd => {
                const wrapper = dd.parentElement;
                if (wrapper && !wrapper.contains(e.target)) {
                    dd.classList.remove('active');
                }
            });
        });
        
        // =====================
        // AUTOCOMPLETE FUNCTIONS
        // =====================
        let autocompleteOptions = {
            owner: [],
            where: [],
            informed: []
        };
        
        function buildAutocompleteOptions() {
            // Extract unique values from all tasks
            const owners = new Set();
            const wheres = new Set();
            const informeds = new Set();
            
            processDataRaw.forEach(task => {
                if (task.owner && task.owner.trim()) {
                    // Split by common delimiters
                    task.owner.split(/[,;\/]/).forEach(o => {
                        const trimmed = o.trim();
                        if (trimmed) owners.add(trimmed);
                    });
                }
                if (task.whereWorkDone && task.whereWorkDone.trim()) {
                    task.whereWorkDone.split(/[,;\/]/).forEach(w => {
                        const trimmed = w.trim();
                        if (trimmed) wheres.add(trimmed);
                    });
                }
                if (task.informed && task.informed.trim()) {
                    task.informed.split(/[,;\/]/).forEach(i => {
                        const trimmed = i.trim();
                        if (trimmed) informeds.add(trimmed);
                    });
                }
            });
            
            autocompleteOptions.owner = [...owners].sort();
            autocompleteOptions.where = [...wheres].sort();
            autocompleteOptions.informed = [...informeds].sort();
        }
        
        function showAutocomplete(type) {
            filterAutocomplete(type, '');
            const dropdownId = type === 'owner' ? 'ownerDropdown' : 
                              type === 'where' ? 'whereDropdown' : 'informedDropdown';
            document.getElementById(dropdownId).classList.add('active');
        }
        
        function filterAutocomplete(type, query) {
            const dropdownId = type === 'owner' ? 'ownerDropdown' : 
                              type === 'where' ? 'whereDropdown' : 'informedDropdown';
            const inputId = type === 'owner' ? 'editOwner' : 
                           type === 'where' ? 'editWhereWorkDone' : 'editInformed';
            
            const dropdown = document.getElementById(dropdownId);
            const options = autocompleteOptions[type] || [];
            const lowerQuery = query.toLowerCase().trim();
            
            // Filter options
            let filtered = options.filter(opt => 
                opt.toLowerCase().includes(lowerQuery)
            );
            
            // Limit to 10
            filtered = filtered.slice(0, 10);
            
            dropdown.innerHTML = '';
            
            filtered.forEach(opt => {
                const div = document.createElement('div');
                div.className = 'autocomplete-option';
                div.textContent = opt;
                div.onclick = () => selectAutocompleteOption(inputId, opt, dropdownId);
                dropdown.appendChild(div);
            });
            
            // Add "Add new" option if query doesn't match any existing
            if (lowerQuery && !options.some(o => o.toLowerCase() === lowerQuery)) {
                const addNew = document.createElement('div');
                addNew.className = 'autocomplete-option add-new';
                addNew.textContent = `+ Add "${query}"`;
                addNew.onclick = () => {
                    document.getElementById(inputId).value = query;
                    dropdown.classList.remove('active');
                };
                dropdown.appendChild(addNew);
            }
            
            if (dropdown.children.length === 0) {
                const noMatch = document.createElement('div');
                noMatch.className = 'autocomplete-option';
                noMatch.style.color = '#999';
                noMatch.textContent = 'No matches found';
                dropdown.appendChild(noMatch);
            }
            
            dropdown.classList.add('active');
        }
        
        function selectAutocompleteOption(inputId, value, dropdownId) {
            document.getElementById(inputId).value = value;
            document.getElementById(dropdownId).classList.remove('active');
        }
        
        // =====================
        // LINKS EDITOR FUNCTIONS
        // =====================
        function populateLinksEditor(linksText) {
            const container = document.getElementById('linksEditor');
            container.innerHTML = '';
            
            if (!linksText || !linksText.trim()) {
                // Show empty state
                return;
            }
            
            // Parse links - support both "description: URL" and just "URL" formats
            const lines = linksText.split('\n').filter(l => l.trim());
            
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                let url = '';
                let description = '';
                
                // Check for URL pattern
                const urlMatch = trimmed.match(/(https?:\/\/[^\s]+)/i);
                if (urlMatch) {
                    url = urlMatch[1];
                    // Get description as everything before the URL
                    description = trimmed.substring(0, trimmed.indexOf(url)).replace(/[:|\-]\s*$/, '').trim();
                    if (!description) {
                        // Try to extract domain as description
                        try {
                            const urlObj = new URL(url);
                            description = urlObj.hostname.replace('www.', '');
                        } catch (e) {
                            description = 'Link ' + (index + 1);
                        }
                    }
                } else {
                    // No URL found, treat as description
                    description = trimmed;
                }
                
                addLinkRowWithData(url, description);
            });
        }
        
        function addLinkRow() {
            addLinkRowWithData('', '');
        }
        
        function addLinkRowWithData(url, description) {
            const container = document.getElementById('linksEditor');
            
            // Add header if first row
            if (container.children.length === 0) {
                const header = document.createElement('div');
                header.className = 'link-row-header';
                header.innerHTML = '<span>Description</span><span>URL</span><span></span>';
                container.appendChild(header);
            }
            
            const row = document.createElement('div');
            row.className = 'link-row';
            row.innerHTML = `
                <input type="text" class="link-desc" placeholder="Link description..." value="${escapeHtmlAttr(description)}">
                <input type="text" class="link-url" placeholder="https://..." value="${escapeHtmlAttr(url)}">
                <button type="button" class="remove-link-btn" onclick="removeLinkRow(this)">×</button>
            `;
            container.appendChild(row);
        }
        
        function removeLinkRow(btn) {
            const row = btn.parentElement;
            const container = row.parentElement;
            row.remove();
            
            // Remove header if no more rows
            const rows = container.querySelectorAll('.link-row');
            if (rows.length === 0) {
                container.innerHTML = '';
            }
        }
        
        function getLinksFromEditor() {
            const container = document.getElementById('linksEditor');
            const rows = container.querySelectorAll('.link-row');
            const links = [];
            
            rows.forEach(row => {
                const desc = row.querySelector('.link-desc').value.trim();
                const url = row.querySelector('.link-url').value.trim();
                
                if (url) {
                    if (desc) {
                        links.push(`${desc}: ${url}`);
                    } else {
                        links.push(url);
                    }
                } else if (desc) {
                    links.push(desc);
                }
            });
            
            return links.join('\n');
        }
        
        function openEditModal(taskNumber) {
            const task = processDataRaw.find(t => t.taskNumber === taskNumber);
            if (!task) return;
            
            editingTaskNumber = taskNumber;
            
            // Populate category dropdown
            const categorySelect = document.getElementById('editCategory');
            categorySelect.innerHTML = '';
            const categories = [...new Set(processDataRaw.map(t => t.category))].sort();
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                option.selected = cat === task.category;
                categorySelect.appendChild(option);
            });
            
            // Populate basic fields
            document.getElementById('editTaskNumber').value = taskNumber;
            document.getElementById('editDeliverable').value = task.deliverable || '';
            document.getElementById('editOwner').value = task.owner || '';
            document.getElementById('editInformed').value = task.informed || '';
            
            // Populate rich editor - show HTML directly for editing
            const editor = document.getElementById('editDescriptionEditor');
            // If description has HTML, show it as-is for WYSIWYG editing
            // If it's plain text, convert it to HTML first
            let descHtml = task.description || '';
            if (descHtml && !/<[a-z][\s\S]*>/i.test(descHtml)) {
                // Plain text - convert bullets and newlines to HTML
                descHtml = descHtml
                    .replace(/\n\* /g, '</li><li>')
                    .replace(/^\* /g, '<li>')
                    .replace(/\n/g, '<br>');
                if (descHtml.includes('<li>')) {
                    const items = descHtml.replace(/<li>/g, '').split('</li>').filter(s => s.trim());
                    descHtml = '<ul>' + items.map(s => `<li>${s.trim()}</li>`).join('') + '</ul>';
                }
            }
            editor.innerHTML = descHtml;
            
            // Populate links editor
            populateLinksEditor(task.links || '');
            
            // Build autocomplete options
            buildAutocompleteOptions();
            
            // Build role options and populate selected roles
            buildRoleOptions();
            selectedRoles = [];
            if (task.whereWorkDone && task.whereWorkDone.trim()) {
                task.whereWorkDone.split(/\n/).forEach(r => {
                    const trimmed = r.trim();
                    if (trimmed) selectedRoles.push(trimmed);
                });
            }
            renderSelectedRoles();
            document.getElementById('roleSearch').value = '';
            document.getElementById('roleDropdown').classList.remove('active');
            
            // Populate selected dependencies
            selectedDependencies = [];
            const depLines = (task.dependencies || '').split('\n').filter(d => d.trim());
            depLines.forEach(depText => {
                const matchingTask = processDataRaw.find(t => t.deliverable.trim() === depText.trim());
                if (matchingTask) {
                    selectedDependencies.push({
                        taskNumber: matchingTask.taskNumber,
                        deliverable: matchingTask.deliverable
                    });
                }
            });
            renderSelectedDependencies();
            
            // Clear search
            document.getElementById('dependencySearch').value = '';
            document.getElementById('dependencyDropdown').classList.remove('active');
            
            // Hide all autocomplete dropdowns
            document.querySelectorAll('.autocomplete-dropdown').forEach(d => d.classList.remove('active'));
            
            document.getElementById('editModalTitle').textContent = `Edit Task #${taskNumber}`;
            document.getElementById('editModal').classList.add('active');
        }
        
        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
            document.getElementById('dependencyDropdown').classList.remove('active');
            document.getElementById('roleDropdown').classList.remove('active');
            editingTaskNumber = null;
            selectedDependencies = [];
            selectedRoles = [];
        }
        
        async function saveTaskEdit() {
            if (!editingTaskNumber) return;
            
            const taskIndex = processDataRaw.findIndex(t => t.taskNumber === editingTaskNumber);
            if (taskIndex === -1) return;
            
            try {
                // Get description from rich editor
                const editor = document.getElementById('editDescriptionEditor');
                const descriptionHtml = editor ? editor.innerHTML : '';
                
                // Get dependencies from selected list
                const dependenciesText = selectedDependencies.map(d => d.deliverable).join('\n');
                
                // Get links from link editor rows
                const linksText = getLinksFromEditor();
                
                // Build updates object
                const updates = {
                    deliverable: document.getElementById('editDeliverable').value || '',
                    category: document.getElementById('editCategory').value || '',
                    description: descriptionHtml,
                    owner: document.getElementById('editOwner').value || '',
                    whereWorkDone: selectedRoles.join('\n'),
                    informed: document.getElementById('editInformed').value || '',
                    dependencies: dependenciesText,
                    links: linksText
                };
                
                // Update local task data
                const task = processDataRaw[taskIndex];
                Object.assign(task, updates);
                
                // Store task number before closing modal
                const savedTaskNum = editingTaskNumber;
                
                // Close modal first
                closeEditModal();
                
                // Refresh views with error handling
                try {
                    // Regenerate dependency connections
                    dependencyConnections = generateDependencyConnections(processDataRaw);
                    
                    if (currentView === 'list') {
                        renderListView();
                    } else {
                        renderSubwayMap();
                    }
                    
                    // Update category filter chips
                    renderCategoryFilters();
                } catch (renderError) {
                    console.error('Error refreshing view:', renderError);
                }
                
                // Sync to Smartsheet if connected
                if (smartsheetConfig.connected && task.rowId) {
                    const syncSuccess = await saveTaskToSmartsheet(task, updates);
                    if (syncSuccess) {
                        showToast('✓ Task #' + savedTaskNum + ' saved to Smartsheet');
                    } else {
                        showToast('✓ Task #' + savedTaskNum + ' saved locally (Smartsheet sync failed)', true);
                    }
                } else {
                    showToast('✓ Task #' + savedTaskNum + ' updated locally. Export CSV or connect to Smartsheet to persist.');
                }
                
            } catch (error) {
                console.error('Error saving task:', error);
                showToast('Error saving task. Please try again.', true);
            }
        }
        
        function exportSingleTask() {
            if (!editingTaskNumber) return;
            
            const task = processDataRaw.find(t => t.taskNumber === editingTaskNumber);
            if (!task) return;
            
            // Create CSV row
            const escapeCSV = (val) => {
                if (!val) return '';
                val = String(val);
                if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                    return '"' + val.replace(/"/g, '""') + '"';
                }
                return val;
            };
            
            const row = [
                escapeCSV(task.governanceProcess),
                escapeCSV(task.category),
                escapeCSV(task.taskNumber),
                escapeCSV(task.deliverable),
                escapeCSV(task.description),
                escapeCSV(task.owner),
                escapeCSV(task.whereWorkDone),
                escapeCSV(task.informed),
                escapeCSV(task.dependencies),
                escapeCSV(task.links)
            ].join(',');
            
            // Copy to clipboard
            navigator.clipboard.writeText(row).then(() => {
                showToast('CSV row copied to clipboard!');
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = row;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast('CSV row copied!');
            });
        }
        
        function exportAllToCSV() {
            const escapeCSV = (val) => {
                if (!val) return '';
                val = String(val);
                if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                    return '"' + val.replace(/"/g, '""') + '"';
                }
                return val;
            };
            
            // Header
            const headers = [
                'Launch Governance Process', 'Category', 'Task #', 'Deliverable', 'Description',
                'Owner', 'Where the work gets done', 'Informed', 'Dependencies', 'Useful Links/ Supporting Documentation',
                'Status', 'GL Project Plan Review (Y/N) & Comments',
                'NOI -> GL Enablement', 'Product ->GL Enablement', 'Solution (BUY - CAPEX) -> IQ & FQ',
                'FQ -> IQ', 'IQ->FQ', 'SKU update (small change)', 'Significant arch.change',
                'New Route to Market', 'Change Order (IQ/FQ)'
            ];
            
            let csv = headers.map(escapeCSV).join(',') + '\n';
            
            // Data rows
            processDataRaw.forEach(task => {
                const row = [
                    task.governanceProcess,
                    task.category,
                    task.taskNumber,
                    task.deliverable,
                    task.description,
                    task.owner,
                    task.whereWorkDone,
                    task.informed,
                    task.dependencies,
                    task.links,
                    '', // Status
                    '', // GL Project Plan Review
                    task.scenarios.noiToGl ? 'TRUE' : '',
                    task.scenarios.productToGl ? 'TRUE' : '',
                    task.scenarios.solutionBuyCapex ? 'TRUE' : '',
                    task.scenarios.fqToIq ? 'TRUE' : '',
                    task.scenarios.iqToFq ? 'TRUE' : '',
                    task.scenarios.skuUpdate ? 'TRUE' : '',
                    task.scenarios.significantArchChange ? 'TRUE' : '',
                    task.scenarios.newRouteToMarket ? 'TRUE' : '',
                    task.scenarios.changeOrder ? 'TRUE' : ''
                ].map(escapeCSV).join(',');
                csv += row + '\n';
            });
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `gl_ready_data_export_${new Date().toISOString().slice(0,10)}.csv`;
            link.click();
            
            showToast('CSV exported!');
        }
        
        function showToast(message, isError = false) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 2rem;
                left: 50%;
                transform: translateX(-50%);
                background: ${isError ? '#c62828' : '#01A982'};
                color: white;
                padding: 1rem 2rem;
                border-radius: 8px;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 3000;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Override applyFilters to also update list view
        const originalApplyFilters = applyFilters;
        applyFilters = function() {
            originalApplyFilters();
            applyListFilters();
        };
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeData();
        });
        
        // Also initialize immediately if DOM is already ready
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initializeData();
        }
    </script>
</body>
</html>
